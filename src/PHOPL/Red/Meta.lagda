\AgdaHide{
\begin{code}
module PHOPL.Red.Meta where
open import Data.Empty renaming (⊥ to False)
open import Data.Unit
open import Data.Vec
open import Data.Product renaming (_,_ to _,p_)
open import Data.List
open import Prelims
open import Prelims.Closure
open import PHOPL.Grammar
open import PHOPL.PathSub
open import PHOPL.Red.Base
\end{code}
}

\begin{code}
postulate R-det : ∀ {V} {K} {C} {c : Con (SK C K)} {E : ListAbs V C} {F} {G} → R c E F → R c E G → F ≡ G
{- R-det βT βT = refl
R-det (βR _ _) (βR _ _) = refl
R-det (dir-ref _) (dir-ref _) = refl
R-det (plus-univ _) (plus-univ _) = refl
R-det (minus-univ _) (minus-univ _) = refl
R-det (ref⊃*univ _ _) (ref⊃*univ _ _) = refl
R-det (univ⊃*ref _ _) (univ⊃*ref _ _) = refl
R-det (univ⊃*univ _ _) (univ⊃*univ _ _) = refl
R-det (ref⊃*ref _ _) (ref⊃*ref _ _) = refl
R-det (refref _ _) (refref _ _) = refl
R-det (refref _ _) (reflam _ _ _ _ ())
R-det (βE _ _ _ _) (βE _ _ _ _) = refl
R-det (reflam _ _ _ _ _) (reflam _ _ _ _ _) = refl
R-det (reflam _ _ _ _ ()) (refref _ _) -}
\end{code}

Let $\rightarrow^?$ be the reflexive closure of $\rightarrow$;
let $\twoheadrightarrow^+$ be the transitive closure;
let \emph{reduction} $\twoheadrightarrow$ be the reflexive, transitive closure; and \emph{conversion} $\simeq$ the equivalence relation generated by $\rightarrow$.
\end{definition}

\AgdaHide{
\begin{code}
postulate nf-is-nf : ∀ {V K} {E E' : Expression V K} → nf E → E ⇒ E' → False
{- nf-is-nf (nfvar _) ()
nf-is-nf nf⊥ (redex ())
nf-is-nf nf⊥ (app ())
nf-is-nf (nf⊃ _ _) (redex ())
nf-is-nf (nf⊃ nfφ _) (app (appl φ⇒φ')) = nf-is-nf nfφ φ⇒φ'
nf-is-nf (nf⊃ _ nfψ) (app (appr (appl ψ⇒ψ'))) = nf-is-nf nfψ ψ⇒ψ'
nf-is-nf (nf⊃ _ _) (app (appr (appr ())))
nf-is-nf (nfΛT _ _) (redex ())
nf-is-nf (nfΛT _ nfM) (app (appl M⇒M')) = nf-is-nf nfM M⇒M'
nf-is-nf (nfΛT _ _) (app (appr ()))
nf-is-nf (nfappTvar _ _) (redex ())
nf-is-nf (nfappTvar _ _) (app (appl ()))
nf-is-nf (nfappTvar _ nfM) (app (appr (appl M⇒M'))) = nf-is-nf nfM M⇒M'
nf-is-nf (nfappTvar _ _) (app (appr (appr ())))
nf-is-nf (nfappT⊥ _) (redex ())
nf-is-nf (nfappT⊥ _) (app (appl ⊥⇒E')) = nf-is-nf nf⊥ ⊥⇒E'
nf-is-nf (nfappT⊥ nfM) (app (appr (appl M⇒M'))) = nf-is-nf nfM M⇒M'
nf-is-nf (nfappT⊥ _) (app (appr (appr ())))
nf-is-nf (nfappT⊃ _ _ _) (redex ())
nf-is-nf (nfappT⊃ nfM nfM' _) (app (appl M⊃M'⇒E')) = nf-is-nf (nf⊃ nfM nfM') M⊃M'⇒E'
nf-is-nf (nfappT⊃ _ _ nfN) (app (appr (appl N⇒N'))) = nf-is-nf nfN N⇒N'
nf-is-nf (nfappT⊃ _ _ _) (app (appr (appr ())))
nf-is-nf (nfappTappT _ _) (redex ())
nf-is-nf (nfappTappT nfMM' _) (app (appl MM'⇒E')) = nf-is-nf nfMM' MM'⇒E'
nf-is-nf (nfappTappT _ nfN) (app (appr (appl N⇒N'))) = nf-is-nf nfN N⇒N'
nf-is-nf (nfappTappT nfE nfE₁) (app (appr (appr ())))
nf-is-nf (nfΛP _ _) (redex ())
nf-is-nf (nfΛP nfφ _) (app (appl φ⇒φ')) = nf-is-nf nfφ φ⇒φ'
nf-is-nf (nfΛP _ nfδ) (app (appr (appl δ⇒δ'))) = nf-is-nf nfδ δ⇒δ'
nf-is-nf (nfΛP _ _) (app (appr (appr ())))
nf-is-nf (nfappPvar _ _) (redex ())
nf-is-nf (nfappPvar _ _) (app (appl ()))
nf-is-nf (nfappPvar _ nfδ) (app (appr (appl δ⇒δ'))) = nf-is-nf nfδ δ⇒δ'
nf-is-nf (nfappPvar _ _) (app (appr (appr ())))
nf-is-nf (nfappPappP _ _) (redex ())
nf-is-nf (nfappPappP nfδε _) (app (appl δε⇒E')) = nf-is-nf nfδε δε⇒E'
nf-is-nf (nfappPappP _ nfε') (app (appr (appl ε'⇒E'))) = nf-is-nf nfε' ε'⇒E'
nf-is-nf (nfappPappP _ _) (app (appr (appr ())))
nf-is-nf (nfappPdir _ _) (redex ())
nf-is-nf (nfappPdir nfdP _) (app (appl dP⇒E')) = nf-is-nf nfdP dP⇒E'
nf-is-nf (nfappPdir _ nfδ) (app (appr (appl δ⇒δ'))) = nf-is-nf nfδ δ⇒δ'
nf-is-nf (nfappPdir _ _) (app (appr (appr ())))
nf-is-nf (nfdirvar (var _) _ (nruvar _)) (redex ())
nf-is-nf (nfdirvar _ _ nru⊃*) (redex ())
nf-is-nf (nfdirvar _ _ nruλλλ) (redex ())
nf-is-nf (nfdirvar _ _ nruapp*) (redex ())
nf-is-nf (nfdirvar _ nfP _) (app (appl P⇒P')) = nf-is-nf nfP P⇒P'
nf-is-nf (nfdirvar _ _ _) (app (appr ()))
nf-is-nf (nfreff _) (redex ())
nf-is-nf (nfreff nfM) (app (appl M⇒M')) = nf-is-nf nfM M⇒M'
nf-is-nf (nfreff _) (app (appr ()))
nf-is-nf (nf⊃*l _ _ (nruvar _)) (redex ()) 
nf-is-nf (nf⊃*l _ _ nru⊃*) (redex ()) 
nf-is-nf (nf⊃*l _ _ nruλλλ) (redex ()) 
nf-is-nf (nf⊃*l _ _ nruapp*) (redex ()) 
nf-is-nf (nf⊃*l nfP _ _) (app (appl P⇒P')) = nf-is-nf nfP P⇒P'
nf-is-nf (nf⊃*l _ nfQ _) (app (appr (appl Q⇒Q'))) = nf-is-nf nfQ Q⇒Q'
nf-is-nf (nf⊃*l _ _ _) (app (appr (appr ())))
nf-is-nf (nf⊃*r _ _ (nruvar _)) (redex ()) 
nf-is-nf (nf⊃*r _ _ nru⊃*) (redex ()) 
nf-is-nf (nf⊃*r _ _ nruλλλ) (redex ()) 
nf-is-nf (nf⊃*r _ _ nruapp*) (redex ()) 
nf-is-nf (nf⊃*r nfP _ _) (app (appl P⇒P')) = nf-is-nf nfP P⇒P'
nf-is-nf (nf⊃*r _ nfQ _) (app (appr (appl Q⇒Q'))) = nf-is-nf nfQ Q⇒Q'
nf-is-nf (nf⊃*r _ _ _) (app (appr (appr ())))
nf-is-nf (nfuniv _ _ _ _) (redex ())
nf-is-nf (nfuniv nfφ _ _ _) (app (appl φ⇒φ')) = nf-is-nf nfφ φ⇒φ'
nf-is-nf (nfuniv _ nfψ _ _) (app (appr (appl ψ⇒ψ'))) = nf-is-nf nfψ ψ⇒ψ'
nf-is-nf (nfuniv _ _ nfδ _) (app (appr (appr (appl δ⇒δ')))) = nf-is-nf nfδ δ⇒δ'
nf-is-nf (nfuniv _ _ _ nfε) (app (appr (appr (appr (appl ε⇒ε'))))) = nf-is-nf nfε ε⇒ε'
nf-is-nf (nfuniv _ _ _ _) (app (appr (appr (appr (appr ())))))
nf-is-nf (nfλλλ _) (redex ())
nf-is-nf (nfλλλ nfP) (app (appl P⇒P')) = nf-is-nf nfP P⇒P'
nf-is-nf (nfλλλ _) (app (appr ()))
nf-is-nf (nfapp* _ _ _ _ (nrλvar _)) (redex ())
nf-is-nf (nfapp* _ _ _ _ nrλ⊃*) (redex ())
nf-is-nf (nfapp* _ _ _ _ nrλuniv) (redex ())
nf-is-nf (nfapp* _ _ _ _ nrλapp*) (redex ())
nf-is-nf (nfapp* nfM _ _ _ _) (app (appl M⇒M')) = nf-is-nf nfM M⇒M'
nf-is-nf (nfapp* _ nfN _ _ _) (app (appr (appl N⇒N'))) = nf-is-nf nfN N⇒N'
nf-is-nf (nfapp* _ _ nfP _ _) (app (appr (appr (appl P⇒P')))) = nf-is-nf nfP P⇒P'
nf-is-nf (nfapp* _ _ _ nfQ _) (app (appr (appr (appr (appl Q⇒Q'))))) = nf-is-nf nfQ Q⇒Q'
nf-is-nf (nfapp* _ _ _ _ _) (app (appr (appr (appr (appr ()))))) -}

postulate nfredexproof : ∀ {V} {AA} {c : Con (SK AA (varKind -Proof))} {EE EE' : ListAbs V AA} {δ} → R c EE δ → EE ⇒ EE' → False
{-nfredexproof (βR nfΛPφδ _) (appl ΛPφδ⇒E') = nf-is-nf nfΛPφδ ΛPφδ⇒E'
nfredexproof (βR _ nfε) (appr (appl ε⇒ε')) = nf-is-nf nfε ε⇒ε'
nfredexproof (βR _ _) (appr (appr ()))
nfredexproof (dir-ref nfrefφ) (appl refφ⇒E') = nf-is-nf nfrefφ refφ⇒E'
nfredexproof (dir-ref _) (appr ())
nfredexproof (plus-univ nfP) (appl P⇒P') = nf-is-nf nfP P⇒P'
nfredexproof (plus-univ _) (appr ())
nfredexproof (minus-univ nfP) (appl P⇒P') = nf-is-nf nfP P⇒P'
nfredexproof (minus-univ _) (appr ())-}

nfredexpath : ∀ {V} {AA} {c : Con (SK AA (varKind -Path))} {EE EE' : ListAbs V AA} {P} → R c EE P → EE ⇒ EE' → False
nfredexpath (ref⊃*univ nfrefφ _) (appl refφ⇒EE') = nf-is-nf nfrefφ refφ⇒EE'
nfredexpath (ref⊃*univ _ nfunivδε) (appr (appl univδε⇒EE')) = nf-is-nf nfunivδε univδε⇒EE'
nfredexpath (ref⊃*univ _ _) (appr (appr ()))
nfredexpath (univ⊃*ref nfunivδε _) (appl univδε⇒EE') = nf-is-nf nfunivδε univδε⇒EE'
nfredexpath (univ⊃*ref _ nfrefχ) (appr (appl refχ⇒EE')) = nf-is-nf nfrefχ refχ⇒EE'
nfredexpath (univ⊃*ref _ _) (appr (appr ()))
nfredexpath (univ⊃*univ nfunivδε _) (appl univδε⇒EE') = nf-is-nf nfunivδε univδε⇒EE'
nfredexpath (univ⊃*univ _ nfunivδ'ε') (appr (appl univδ'ε'⇒EE')) = nf-is-nf nfunivδ'ε' univδ'ε'⇒EE'
nfredexpath (univ⊃*univ _ _) (appr (appr ())) 
nfredexpath (ref⊃*ref nfrefφ _) (appl refφ⇒EE') = nf-is-nf nfrefφ refφ⇒EE'
nfredexpath (ref⊃*ref _ nfrefψ) (appr (appl refψ⇒EE')) = nf-is-nf nfrefψ refψ⇒EE'
nfredexpath (ref⊃*ref _ _) (appr (appr ()))
nfredexpath (refref _ nfrefN) (appl N⇒EE') = nf-is-nf nfrefN (app (appl N⇒EE'))
nfredexpath (refref _ nfrefN) (appr (appl N⇒EE')) = nf-is-nf nfrefN (app (appl N⇒EE'))
nfredexpath (refref nfrefM _) (appr (appr (appl refM⇒EE'))) = nf-is-nf nfrefM refM⇒EE'
nfredexpath (refref _ nfrefN) (appr (appr (appr (appl refN⇒EE')))) = nf-is-nf nfrefN refN⇒EE'
nfredexpath (refref _ _) (appr (appr (appr (appr ()))))
nfredexpath (βE nfM _ _ _) (appl M⇒EE') = nf-is-nf nfM M⇒EE'
nfredexpath (βE _ nfN _ _) (appr (appl N⇒EE')) = nf-is-nf nfN N⇒EE'
nfredexpath (βE _ _ nfΛAP _) (appr (appr (appl ΛAP⇒EE'))) = nf-is-nf nfΛAP ΛAP⇒EE'
nfredexpath (βE _ _ _ nfQ) (appr (appr (appr (appl Q⇒EE')))) = nf-is-nf nfQ Q⇒EE'
nfredexpath (βE _ _ _ _) (appr (appr (appr (appr ()))))
nfredexpath (reflam nfN _ _ _ _) (appl N⇒EE') = nf-is-nf nfN N⇒EE'
nfredexpath (reflam _ nfN' _ _ _) (appr (appl N'⇒EE')) = nf-is-nf nfN' N'⇒EE'
nfredexpath (reflam _ _ nfΛAM _ _) (appr (appr (appl ΛAM⇒EE'))) = nf-is-nf nfΛAM ΛAM⇒EE'
nfredexpath (reflam _ _ _ nfP _) (appr (appr (appr (appl P⇒EE')))) = nf-is-nf nfP P⇒EE'
nfredexpath (reflam _ _ _ _ _) (appr (appr (appr (appr ()))))
\end{code}
}

\begin{lm}
If $\univ{\phi}{\psi}{\delta}{\epsilon} \rightarrow E$ then $E$ is formed by reducing
one of $\phi$, $\psi$, $\delta$, $\epsilon$.
\end{lm}

\AgdaHide{
\begin{code}
postulate univ-osrE : ∀ {V} {φ} {ψ} {δ} {ε} {C : Path V → Set} →
                    (∀ φ' → φ ⇒ φ' → C (univ φ' ψ δ ε)) →
                    (∀ ψ' → ψ ⇒ ψ' → C (univ φ ψ' δ ε)) →
                    (∀ δ' → δ ⇒ δ' → C (univ φ ψ δ' ε)) →
                    (∀ ε' → ε ⇒ ε' → C (univ φ ψ δ ε')) →
                    ∀ {P} → univ φ ψ δ ε ⇒ P → C P
{- univ-osrE _ _ _ _ (redex ())
univ-osrE hypφ _ _ _ (app (appl φ⇒φ')) = hypφ _ φ⇒φ'
univ-osrE _ hypψ _ _ (app (appr (appl ψ⇒ψ'))) = hypψ _ ψ⇒ψ'
univ-osrE _ _ hypδ _ (app (appr (appr (appl δ⇒δ')))) = hypδ _ δ⇒δ'
univ-osrE _ _ _ hypε (app (appr (appr (appr (appl ε⇒ε'))))) = hypε _ ε⇒ε'
univ-osrE _ _ _ _ (app (appr (appr (appr (appr ()))))) -}

postulate eq-resp-conv : ∀ {V} {M M' N N' : Term V} {A : Type} →
                       M ≃ M' → N ≃ N' → M ≡〈 A 〉 N ≃ M' ≡〈 A 〉 N'
{- eq-resp-conv M≃M' N≃N' = app-resp-conv (trans-conv (convl M≃M') (convr (convl N≃N'))) -}

postulate R-creates-rep : creates' REP

postulate R-respects-replacement : respects' REP

postulate osr-rep : ∀ {U} {V} {C} {K} {E E' : Subexp U C K} {ρ : Rep U V} →
                  E ⇒ E' → E 〈 ρ 〉 ⇒ E' 〈 ρ 〉
--osr-rep = aposrr REP R-respects-replacement

postulate red-rep : ∀ {U} {V} {C} {K} {E E' : Subexp U C K} {ρ : Rep U V} →
                  E ↠ E' → E 〈 ρ 〉 ↠ E' 〈 ρ 〉
-- red-rep = apredr REP R-respects-replacement

postulate R-creates-replacement : creates' REP

postulate R-respects-sub : respects' SUB

postulate osr-subl : ∀ {U} {V} {C} {K} {E F : Subexp U C K} {σ : Sub U V} → E ⇒ F → E ⟦ σ ⟧ ⇒ F ⟦ σ ⟧
--osr-subl = aposrr SUB R-respects-sub

postulate red-subl : ∀ {U} {V} {C} {K} {E F : Subexp U C K} {σ : Sub U V} → E ↠ F → E ⟦ σ ⟧ ↠ F ⟦ σ ⟧
--red-subl E↠F = respects-red (aposrr SUB R-respects-sub) E↠F

postulate red-subr : ∀ {U} {V} {C} {K} (E : Subexp U C K) {ρ σ : Sub U V} → ρ ↠s σ → E ⟦ ρ ⟧ ↠ E ⟦ σ ⟧

postulate ⊥SN : ∀ {V} → SN {V} ⊥

postulate ⊃SN : ∀ {V} {φ ψ : Term V} → SN φ → SN ψ → SN (φ ⊃ ψ)

postulate SN-βexp : ∀ {V} {φ : Term V} {δ : Proof (V , -Proof)} {ε : Proof V} →
                  SN ε → SN (δ ⟦ x₀:= ε ⟧) → SN (appP (ΛP φ δ) ε) 

postulate univ-red : ∀ {V} {φ φ' ψ ψ' : Term V} {δ} {δ'} {ε} {ε'} → 
                   φ ↠ φ' → ψ ↠ ψ' → δ ↠ δ' → ε ↠ ε' → univ φ ψ δ ε ↠ univ φ' ψ' δ' ε'

postulate ΛP-red : ∀ {V} {φ φ' : Term V} {δ} {δ'} → φ ↠ φ' → δ ↠ δ' → ΛP φ δ ↠ ΛP φ' δ'

postulate ⊃-red : ∀ {V} {φ φ' ψ ψ' : Term V} → φ ↠ φ' → ψ ↠ ψ' → φ ⊃ ψ ↠ φ' ⊃ ψ'
--⊃-red {V} {φ} {φ'} {ψ} {ψ'} φ↠φ' ψ↠ψ' = app-red (∷-red φ↠φ' (∷-redl ψ↠ψ'))

postulate appP-red : ∀ {V} {δ δ' ε ε' : Proof V} → δ ↠ δ' → ε ↠ ε' → appP δ ε ↠ appP δ' ε'
--appP-red δ↠δ' ε↠ε' = app-red (∷-red δ↠δ' (∷-redl ε↠ε'))

postulate ⊃*-red : ∀ {V} {P P' Q Q' : Path V} → P ↠ P' → Q ↠ Q' → (P ⊃* Q) ↠ (P' ⊃* Q')

postulate λλλ-red : ∀ {V A} {P Q : Path (V , -Term , -Term , -Path)} → P ↠ Q → λλλ A P ↠ λλλ A Q

postulate app*-red : ∀ {V} {M M' N N' : Term V} {P P' Q Q'} → M ↠ M' → N ↠ N' → P ↠ P' → Q ↠ Q' →
                   app* M N P Q ↠ app* M' N' P' Q'

postulate ru-redex-half-red : ∀ {V} {φ φ' ψ ψ' : Term V} {δ δ'} →
                            φ ↠ φ' → ψ ↠ ψ' → δ ↠ δ' → ru-redex-half φ ψ δ ↠ ru-redex-half φ' ψ' δ'
--ru-redex-half-red φ↠φ' ψ↠ψ' δ↠δ' = ΛP-red (⊃-red φ↠φ' ψ↠ψ') (ΛP-red (red-rep φ↠φ') (appP-red (red-rep (red-rep δ↠δ')) ref))

ru-redex-red : ∀ {V} {φ φ' ψ ψ' χ χ' : Term V} δ δ' ε ε' →
  φ ↠ φ' → ψ ↠ ψ' → χ ↠ χ' → δ ↠ δ' → ε ↠ ε' →
  ru-redex φ ψ χ δ ε ↠ ru-redex φ' ψ' χ' δ' ε'
ru-redex-red _ _ _ _ φ↠φ' ψ↠ψ' χ↠χ' δ↠δ' ε↠ε' = univ-red (⊃-red φ↠φ' ψ↠ψ') (⊃-red φ↠φ' χ↠χ') (ru-redex-half-red φ↠φ' ψ↠ψ' δ↠δ') (ru-redex-half-red φ↠φ' χ↠χ' ε↠ε')

postulate ur-redex-half-red : ∀ {V} {φ φ' ψ ψ' : Term V} {χ χ' δ δ'} →
                            φ ↠ φ' → ψ ↠ ψ' → χ ↠ χ' → δ ↠ δ' →
                            ur-redex-half φ ψ χ δ ↠ ur-redex-half φ' ψ' χ' δ'
--ur-redex-half-red φ↠φ' ψ↠ψ' χ↠χ' δ↠δ' = ΛP-red (⊃-red φ↠φ' ψ↠ψ') (ΛP-red (red-rep χ↠χ') (appP-red ref (appP-red (red-rep (red-rep δ↠δ')) ref)))

postulate ur-redex-red : ∀ {V} {φ φ' ψ ψ' χ χ' : Term V} δ δ' ε ε' →
                       φ ↠ φ' → ψ ↠ ψ' → χ ↠ χ' → δ ↠ δ' → ε ↠ ε' →
                       ur-redex φ ψ χ δ ε ↠ ur-redex φ' ψ' χ' δ' ε'
--ur-redex-red {φ = φ} {φ'} {ψ} {ψ'} {χ} {χ'} _ _ _ _ φ↠φ' ψ↠ψ' χ↠χ' δ↠δ' ε↠ε' = univ-red (⊃-red φ↠φ' χ↠χ') (⊃-red ψ↠ψ' χ↠χ') (ur-redex-half-red φ↠φ' χ↠χ' ψ↠ψ' ε↠ε') (ur-redex-half-red ψ↠ψ' χ↠χ' φ↠φ' δ↠δ')

postulate uu-redex-half-red : ∀ {V} {φ φ₁ φ' φ'₁ ψ ψ₁ : Term V} {δ δ₁ ε ε₁} →
                            φ ↠ φ₁ → φ' ↠ φ'₁ → ψ ↠ ψ₁ → δ ↠ δ₁ → ε ↠ ε₁ →
                            uu-redex-half φ φ' ψ δ ε ↠ uu-redex-half φ₁ φ'₁ ψ₁ δ₁ ε₁
--uu-redex-half-red φ↠φ₁ φ'↠φ'₁ ψ↠ψ₁ δ↠δ₁ ε↠ε₁ = ΛP-red (⊃-red φ↠φ₁ φ'↠φ'₁) (ΛP-red (red-rep ψ↠ψ₁) (appP-red (red-rep (red-rep δ↠δ₁)) (appP-red ref (appP-red (red-rep (red-rep ε↠ε₁)) ref))))

postulate uu-redex-red : ∀ {V} {φ φ₁ φ' φ'₁ ψ ψ₁ ψ' ψ'₁ : Term V} δ {δ₁} δ' {δ'₁} ε {ε₁} ε' {ε'₁} →
                       φ ↠ φ₁ → φ' ↠ φ'₁ → ψ ↠ ψ₁ → ψ' ↠ ψ'₁ → δ ↠ δ₁ → δ' ↠ δ'₁ → ε ↠ ε₁ → ε' ↠ ε'₁ →
                       uu-redex φ φ' ψ ψ' δ δ' ε ε' ↠ uu-redex φ₁ φ'₁ ψ₁ ψ'₁ δ₁ δ'₁ ε₁ ε'₁
--uu-redex-red {φ = φ} {φ₁} {φ'} {φ'₁} {ψ} {ψ₁} {ψ'} {ψ'₁} _ _ _ _ φ↠φ₁ φ'↠φ'₁ ψ↠ψ₁ ψ'↠ψ'₁ δ↠δ₁ δ'↠δ'₁ ε↠ε₁ ε'↠ε'₁ = 
--  univ-red (⊃-red φ↠φ₁ φ'↠φ'₁) (⊃-red ψ↠ψ₁ ψ'↠ψ'₁) (uu-redex-half-red φ↠φ₁ φ'↠φ'₁ ψ↠ψ₁ δ'↠δ'₁ ε↠ε₁) (uu-redex-half-red ψ↠ψ₁ ψ'↠ψ'₁ φ↠φ₁ ε'↠ε'₁ δ↠δ₁)
\end{code}
}

\paragraph{Note}
Contraction is a relation between closed expressions only: if $s \rhd t$ then $s$ and $t$ are closed.  This is not true for $\rightarrow$, $\twoheadrightarrow$ or $\simeq$, however.  For example, we have $\reff{\bot}^+ x \rightarrow (\lambda p:\bot.p)x$.
