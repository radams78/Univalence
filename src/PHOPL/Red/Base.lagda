\AgdaHide{
\begin{code}
module PHOPL.Red.Base where
open import PHOPL.Grammar
open import PHOPL.PathSub
\end{code}
}

\subsection{The Reduction Relation}

\begin{definition}
We make the following definitions simultaneously:
\begin{enumerate}
\item
Let \emph{contraction} $\rhd$ be the relation consisting of the pairs $s \rhd t$ shown in Figure \ref{fig:red}, 
such that $s$ is closed, and every proper subexpression of $s$ is in normal form.
%The only time we need this restriction is that M is in normal form when reducing ref(λx:A.M)_NN' P

\begin{figure}
\begin{framed}
\begin{align*}
(\lambda x:A.M)N & \rhd M[x:=N] & (\lambda p:\phi.\delta)\epsilon & \rhd \delta[p:=\epsilon] \\
 \reff{\phi}^+ & \rhd \lambda p:\phi.p & \reff{\phi}^- & \rhd \lambda p:\phi.p \\
\univ{\phi}{\psi}{\delta}{\epsilon}^+ & \rhd \delta & \univ{\phi}{\psi}{\delta}{\epsilon}^- & \rhd \epsilon
\end{align*}
\begin{align*}
& \reff \phi \supset^* \univ{\psi}{\chi}{\delta}{\epsilon} \\
& \quad \rhd \mathsf{univ}_{\phi \supset \psi,\phi \supset \chi}(\lambda p : \phi \supset \psi. \lambda q : \phi . \delta (p q), 
\lambda p : \phi \supset \chi. \lambda q : \phi . \epsilon (p q)) \\
& \univ{\phi}{\psi}{\delta}{\epsilon} \supset^* \reff{\chi} \\
& \quad \rhd \univ{\phi \supset \chi}{\psi \supset \chi}{\lambda p : \phi \supset \chi . \lambda q : \psi .p (\epsilon q)}{\lambda p : \psi \supset \chi . \lambda q : \phi .p (\delta q)} \\
& \univ{\phi}{\psi}{\delta}{\epsilon} \supset^* \univ{\phi'}{\psi'}{\delta'}{\epsilon'} \\
& \quad \rhd \univ{\phi \supset \phi'}{\psi \supset \psi'}
{\lambda p : \phi \supset \phi' . \lambda q : \psi . \delta' (p (\epsilon q))}{\lambda p : \psi \supset \psi'. \lambda q : \phi . \epsilon' (p (\delta q))}
\end{align*}
\begin{align*}
\reff{\phi} \supset^* \reff{\psi} & \rhd \reff{\phi \supset \psi} \\
\reff{M}_{N_1N_2} \reff{N} & \rhd \reff{MN} \\
(\triplelambda e:x =_A y. P)_{MN}Q & \rhd P[x:=M, y:=N, e:=Q] \\
\text{If $P$ does not have the form } \reff{-}, \text{ then } \\ \reff{\lambda x:A.M}_{N,N'} P & \rhd M \{ x := P : N ∼ N' \}
\end{align*}
\end{framed}
\caption{Contractions for $\lambda o e$}
\label{fig:red}
\end{figure}
\item
{One-step reduction} $\rightarrow$ is the congruence generated by $\rhd$.  That is, the expression $s$ \emph{reduces in one step} to the expression $t$, $s \rightarrow t$, iff $t$ is formed from $s$ by replacing a subexpression $s'$ with a subterm $t'$, where $s' \rhd t'$.  (This subexpression may be in the subscripts of a path application; thus, if $M \rightarrow M'$, then $P_{MN}Q \rightarrow P_{M'N}Q$.)
\item
An expression $s$ is in \emph{normal form} iff there is no expression $t$ such that $s \rightarrow t$.
\end{enumerate}

\begin{code}
--Redex for a path ref ⊃* univ:
ru-redex-half : ∀ {V} → Term V → Term V → Proof V → Proof V
ru-redex-half {V} φ ψ δ = ΛP (φ ⊃ ψ) (ΛP (φ ⇑) (appP (δ ⇑ ⇑) (appP (var x₁) (var x₀))))

ru-redex : ∀ {V} → Term V → Term V → Term V → Proof V → Proof V → Path V
ru-redex φ ψ χ δ ε = univ (φ ⊃ ψ) (φ ⊃ χ) (ru-redex-half φ ψ δ) (ru-redex-half φ χ ε)

--Redex for a path univ ⊃* ref:
ur-redex-half : ∀ {V} → Term V → Term V → Term V → Proof V → Proof V
ur-redex-half φ ψ χ δ = ΛP (φ ⊃ ψ) (ΛP (χ ⇑) (appP (var x₁) (appP (δ ⇑ ⇑) (var x₀))))

ur-redex : ∀ {V} → Term V → Term V → Term V → Proof V → Proof V → Path V
ur-redex φ ψ χ δ ε = univ (φ ⊃ χ) (ψ ⊃ χ) (ur-redex-half φ χ ψ ε) (ur-redex-half ψ χ φ δ)

--Redex for a path univ ⊃* univ;
uu-redex-half : ∀ {V} → Term V → Term V → Term V → Proof V → Proof V → Proof V
uu-redex-half φ φ' ψ δ ε = ΛP (φ ⊃ φ') (ΛP (ψ ⇑) (appP (δ ⇑ ⇑) (appP (var x₁) (appP (ε ⇑ ⇑) (var x₀)))))

uu-redex : ∀ {V} → Term V → Term V → Term V → Term V → Proof V → Proof V → Proof V → Proof V → Path V
uu-redex φ φ' ψ ψ' δ δ' ε ε' = univ (φ ⊃ φ') (ψ ⊃ ψ') (uu-redex-half φ φ' ψ δ' ε) (uu-redex-half ψ ψ' φ ε' δ)

data not-ref-univ {V} : Path V → Set where
  nruvar : ∀ e → not-ref-univ (var e)
  nru⊃*  : ∀ {P} {Q} → not-ref-univ (P ⊃* Q)
  nruλλλ : ∀ {A P} → not-ref-univ (λλλ A P)
  nruapp* : ∀ {M N P Q} → not-ref-univ (app* M N P Q)

data not-ref-λλλ {V} : Path V → Set where
  nrλvar : ∀ e → not-ref-λλλ (var e)
  nrλ⊃*  : ∀ {P Q} → not-ref-λλλ (P ⊃* Q)
  nrλuniv : ∀ {φ ψ δ ε} → not-ref-λλλ (univ φ ψ δ ε)
  nrλapp* : ∀ {M N P Q} → not-ref-λλλ (app* M N P Q)

data not-ref {V} : Path V → Set where
  nrλvar : ∀ e → not-ref (var e)
  nrλ⊃*  : ∀ {P Q} → not-ref (P ⊃* Q)
  nrλuniv : ∀ {φ ψ δ ε} → not-ref (univ φ ψ δ ε)
  nrλλλλ : ∀ {A P} → not-ref (λλλ A P)
  nrλapp* : ∀ {M N P Q} → not-ref (app* M N P Q)

--TODO Do the same for nfappT and nfappP

data β : Reduction where
  βT : ∀ {V} {A} {M} {N} → β {V} -appTerm (ΛT A M ∷ N ∷ []) (M ⟦ x₀:= N ⟧)
  
data R₀ : Reduction
data nf : ∀ {V} {K} → Expression V K → Set

data R₀ where
  βR : ∀ {V} {φ} {δ} {ε} → nf (ΛP φ δ) → nf ε → R₀ {V} -appProof (ΛP φ δ ∷ ε ∷ []) (δ ⟦ x₀:= ε ⟧)
  dir-ref : ∀ {V} {φ} {d} → nf (reff φ) → R₀ {V} (-dir d) (reff φ ∷ []) (ΛP φ (var x₀))
  plus-univ : ∀ {V} {φ} {ψ} {δ} {ε} → nf (univ φ ψ δ ε) → R₀ {V} (-dir -plus) (univ φ ψ δ ε ∷ []) δ 
  minus-univ : ∀ {V} {φ} {ψ} {δ} {ε} → nf (univ φ ψ δ ε) → R₀ {V} (-dir -minus) (univ φ ψ δ ε ∷ []) ε
  ref⊃*univ : ∀ {V} {φ} {ψ} {χ} {δ} {ε} → nf (reff φ) → nf (univ ψ χ δ ε) → R₀ {V} -imp* (reff φ ∷ univ ψ χ δ ε ∷ []) (ru-redex φ ψ χ δ ε)
  univ⊃*ref : ∀ {V} {φ} {ψ} {χ} {δ} {ε} → nf (univ φ ψ δ ε) → nf (reff χ) → R₀ {V} -imp* (univ φ ψ δ ε ∷ reff χ ∷ []) (ur-redex φ ψ χ δ ε)
  univ⊃*univ : ∀ {V} {φ} {φ'} {ψ} {ψ'} {δ} {δ'} {ε} {ε'} → nf (univ φ ψ δ ε) → nf (univ φ' ψ' δ' ε') →
    R₀ {V} -imp* (univ φ ψ δ ε ∷ univ φ' ψ' δ' ε' ∷ []) (uu-redex φ φ' ψ ψ' δ δ' ε ε')
  ref⊃*ref : ∀ {V} {φ} {ψ} → nf (reff φ) → nf (reff ψ) → R₀ {V} -imp* (reff φ ∷ reff ψ ∷ []) (reff (φ ⊃ ψ))
  refref : ∀ {V} {M} {N} → nf (reff M) → nf (reff N) → R₀ {V} -app* (N ∷ N ∷ reff M ∷ reff N ∷ []) (reff (appT M N))
  βE : ∀ {V} {M} {N} {A} {P} {Q} → nf M → nf N → nf (λλλ A P) → nf Q → R₀ {V} -app* (M ∷ N ∷ λλλ A P ∷ Q ∷ []) 
    (P ⟦ x₂:= M ,x₁:= N ,x₀:= Q ⟧)
  reflam : ∀ {V} {N} {N'} {A} {M} {P} → nf N → nf N' → nf (reff (ΛT A M)) → nf P → not-ref P → R₀ {V} -app* (N ∷ N' ∷ reff (ΛT A M) ∷ P ∷ []) (M ⟦⟦ x₀::= P ∶ x₀:= N ∼ x₀:= N' ⟧⟧)

data nf where
  nfvar  : ∀ {V} {K} (x : Var V K) → nf (var x)
  nf⊥    : ∀ {V} → nf {V} ⊥
  nf⊃    : ∀ {V} {φ ψ : Term V} → nf φ → nf ψ → nf (φ ⊃ ψ)
  nfΛT   : ∀ {V} A {M : Term (V , -Term)} → nf M → nf (ΛT A M)
  nfappTvar : ∀ {V} (x : Var V -Term) {M} → nf M → nf (appT (var x) M)
  nfappT⊥   : ∀ {V} {M : Term V} → nf M → nf (appT ⊥ M)
  nfappT⊃   : ∀ {V} {M N P : Term V} → nf M → nf N → nf P → nf (appT (M ⊃ N) P)
  nfappTappT : ∀ {V} {M N P : Term V} → nf (appT M N) → nf P → nf (appT (appT M N) P)
  nfΛP   : ∀ {V} {φ : Term V} {δ} → nf φ → nf δ → nf (ΛP φ δ)
  nfappPvar : ∀ {V} (p : Var V -Proof) {δ} → nf δ → nf (appP (var p) δ)
  nfappPappP : ∀ {V} {δ ε ε' : Proof V} → nf (appP δ ε) → nf ε' → nf (appP (appP δ ε) ε')
  nfappPdir : ∀ {V d} {P : Path V} {δ} → nf (dir d P) → nf δ → nf (appP (dir d P) δ)
  nfdirvar : ∀ {V d} (P : Path V) → nf P → not-ref-univ P → nf (dir d P)
  nfreff : ∀ {V} {M : Term V} → nf M → nf (reff M)
  nf⊃*l  : ∀ {V} {P Q : Path V} → nf P → nf Q → not-ref-univ P → nf (P ⊃* Q)
  nf⊃*r  : ∀ {V} {P Q : Path V} → nf P → nf Q → not-ref-univ Q → nf (P ⊃* Q)
  nfuniv : ∀ {V} {φ ψ : Term V} {δ ε} → nf φ → nf ψ → nf δ → nf ε → nf (univ φ ψ δ ε)
  nfλλλ  : ∀ {V A} {P : Path (V , -Term , -Term , -Path)} → nf P → nf (λλλ A P)
  nfapp* : ∀ {V} {M N : Term V} {P Q} → nf M → nf N → nf P → nf Q → not-ref-λλλ P → nf (app* M N P Q)

data R : Reduction where
  βR : ∀ {V AA K} {c : Con (SK AA K)} {EE : ListAbs V AA} {F} → β c EE F → R c EE F
  R₀R : ∀ {V AA K} {c : Con (SK AA K)} {EE : ListAbs V AA} {F} → R₀ c EE F → R c EE F

open import Reduction PHOPL R public 
\end{code}
