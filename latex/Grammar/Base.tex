\AgdaHide{
\begin{code}%
\>\AgdaComment{\{- Metavariable conventions:\<\\
\>  A, B    range over abstraction kinds\<\\
\>  C       range over kind classes\<\\
\>  AA, BB  range over lists of abstraction kinds\<\\
\>  E, F, G range over subexpressions\<\\
\>  K, L    range over expression kinds including variable kinds\<\\
\>  M, N, P range over expressions\<\\
\>  U, V, W range over alphabets -\}}\<%
\\
\>\AgdaKeyword{open} \AgdaKeyword{import} \AgdaModule{Function}\<%
\\
\>\AgdaKeyword{open} \AgdaKeyword{import} \AgdaModule{Data.List}\<%
\\
\>\AgdaKeyword{open} \AgdaKeyword{import} \AgdaModule{Prelims}\<%
\\
\>\AgdaKeyword{open} \AgdaKeyword{import} \AgdaModule{Grammar.Taxonomy}\<%
\\
%
\\
\>\AgdaKeyword{module} \AgdaModule{Grammar.Base} \AgdaKeyword{where}\<%
\\
%
\\
\>\AgdaKeyword{record} \AgdaRecord{IsGrammar} \AgdaSymbol{(}\AgdaBound{T} \AgdaSymbol{:} \AgdaRecord{Taxonomy}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{open} \AgdaModule{Taxonomy} \AgdaBound{T}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{Constructor} \<[19]%
\>[19]\AgdaSymbol{:} \AgdaFunction{ConKind} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{parent} \<[19]%
\>[19]\AgdaSymbol{:} \AgdaFunction{VarKind} \AgdaSymbol{→} \AgdaDatatype{ExpKind}\<%
\\
%
\\
\>\AgdaKeyword{record} \AgdaRecord{Grammar} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{taxonomy} \AgdaSymbol{:} \AgdaRecord{Taxonomy}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{isGrammar} \AgdaSymbol{:} \AgdaRecord{IsGrammar} \AgdaField{taxonomy}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{open} \AgdaModule{Taxonomy} \AgdaField{taxonomy} \AgdaKeyword{public}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{open} \AgdaModule{IsGrammar} \AgdaField{isGrammar} \AgdaKeyword{public}\<%
\end{code}
}

%<*Expression>
\begin{code}%
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{data} \AgdaDatatype{Subexpression} \AgdaSymbol{(}\AgdaBound{V} \AgdaSymbol{:} \AgdaDatatype{Alphabet}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{C} \AgdaSymbol{→} \AgdaFunction{Kind} \AgdaBound{C} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{Expression} \AgdaSymbol{:} \AgdaDatatype{Alphabet} \AgdaSymbol{→} \AgdaDatatype{ExpKind} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{VExpression} \AgdaSymbol{:} \AgdaDatatype{Alphabet} \AgdaSymbol{→} \AgdaFunction{VarKind} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{Abstraction} \AgdaSymbol{:} \AgdaDatatype{Alphabet} \AgdaSymbol{→} \AgdaFunction{AbsKind} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{ListAbs} \AgdaSymbol{:} \AgdaDatatype{Alphabet} \AgdaSymbol{→} \AgdaDatatype{List} \AgdaFunction{AbsKind} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{Expression} \AgdaBound{V} \AgdaBound{K} \AgdaSymbol{=} \AgdaDatatype{Subexpression} \AgdaBound{V} \AgdaInductiveConstructor{-Expression} \AgdaBound{K}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{VExpression} \AgdaBound{V} \AgdaBound{K} \AgdaSymbol{=} \AgdaFunction{Expression} \AgdaBound{V} \AgdaSymbol{(}\AgdaInductiveConstructor{varKind} \AgdaBound{K}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{Abstraction} \AgdaBound{V} \AgdaSymbol{(}\AgdaInductiveConstructor{SK} \AgdaBound{AA} \AgdaBound{K}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{Expression} \AgdaSymbol{(}\AgdaFunction{extend} \AgdaBound{V} \AgdaBound{AA}\AgdaSymbol{)} \AgdaBound{K}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{ListAbs} \AgdaBound{V} \AgdaBound{AA} \AgdaSymbol{=} \AgdaDatatype{Subexpression} \AgdaBound{V} \AgdaInductiveConstructor{-ListAbs} \AgdaBound{AA}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{infixr} \AgdaNumber{5} \AgdaFixityOp{\_∷\_}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{data} \AgdaDatatype{Subexpression} \AgdaBound{V} \AgdaKeyword{where}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{var} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{K}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Var} \AgdaBound{V} \AgdaBound{K} \AgdaSymbol{→} \AgdaFunction{VExpression} \AgdaBound{V} \AgdaBound{K}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{app} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{AA}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{K}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{Constructor} \AgdaSymbol{(}\AgdaInductiveConstructor{SK} \AgdaBound{AA} \AgdaBound{K}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{ListAbs} \AgdaBound{V} \AgdaBound{AA} \AgdaSymbol{→} \AgdaFunction{Expression} \AgdaBound{V} \AgdaBound{K}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{[]} \AgdaSymbol{:} \AgdaFunction{ListAbs} \AgdaBound{V} \AgdaInductiveConstructor{[]}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{\_∷\_} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{AA}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{Abstraction} \AgdaBound{V} \AgdaBound{A} \AgdaSymbol{→} \AgdaFunction{ListAbs} \AgdaBound{V} \AgdaBound{AA} \AgdaSymbol{→} \AgdaFunction{ListAbs} \AgdaBound{V} \AgdaSymbol{(}\AgdaBound{A} \AgdaInductiveConstructor{∷} \AgdaBound{AA}\AgdaSymbol{)}\<%
\end{code}
%</Expression>

We prove that the constructor \AgdaRef{var} is injective.

\begin{code}%
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{var-inj} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{V}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{K}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y} \AgdaSymbol{:} \AgdaDatatype{Var} \AgdaBound{V} \AgdaBound{K}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaInductiveConstructor{var} \AgdaBound{x} \AgdaDatatype{≡} \AgdaInductiveConstructor{var} \AgdaBound{y} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{≡} \AgdaBound{y}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{var-inj} \AgdaInductiveConstructor{refl} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\end{code}

For the future, we also define the type of all snoc-lists of expressions $(M_1, \ldots, M_n)$
such that $M_i$ is of type $K_i$, given a snoc-list of variable kinds $(K_1, \ldots, K_n)$.

\begin{code}%
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{infixl} \AgdaNumber{20} \AgdaFixityOp{\_snoc\_}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{data} \AgdaDatatype{snocListExp} \AgdaBound{V} \AgdaSymbol{:} \AgdaDatatype{snocList} \AgdaFunction{VarKind} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{[]} \AgdaSymbol{:} \AgdaDatatype{snocListExp} \AgdaBound{V} \AgdaInductiveConstructor{[]}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{\_snoc\_} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{K}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{snocListExp} \AgdaBound{V} \AgdaBound{A} \AgdaSymbol{→} \AgdaFunction{Expression} \AgdaBound{V} \AgdaSymbol{(}\AgdaInductiveConstructor{varKind} \AgdaBound{K}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{snocListExp} \AgdaBound{V} \AgdaSymbol{(}\AgdaBound{A} \AgdaInductiveConstructor{snoc} \AgdaBound{K}\AgdaSymbol{)}\<%
\end{code}

A \emph{reduction} is a relation $\rhd$ between expressions such that, if $E \rhd F$,
then $E$ is not a variable.  It is given by a term $R : \AgdaRef{Reduction}$ such that
$R\, c\, MM\, N$ iff $c[MM] \rhd N$.

\begin{code}%
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{Reduction} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{Reduction} \AgdaSymbol{=} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{V}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{AA}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{K}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{Constructor} \AgdaSymbol{(}\AgdaInductiveConstructor{SK} \AgdaBound{AA} \AgdaBound{K}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{ListAbs} \AgdaBound{V} \AgdaBound{AA} \AgdaSymbol{→} \AgdaFunction{Expression} \AgdaBound{V} \AgdaBound{K} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\end{code}
}
