\begin{code}
open import Prelims
open import Grammar
\end{code}

\section{Reduction}

A \emph{reduction relation} is a relation $R$ between expressions such that, whenever $M R N$, then $M$ and $N$ have the same expression kind,
and $M$ is not a variable.

\begin{code}
module Reduction (G : Grammar) 
  (R : ∀ {V} {K} {C : Grammar.Kind G (Grammar.-Constructor {G} K)} → Grammar.Constructor G C → Grammar.Subexpression G V (Grammar.-Constructor {G} K) C → Grammar.Expression G V K → Set) where
  open Grammar.Grammar G 
\end{code}

We define $\rightarrow_R$ to be the
congruence generated by $R$, and $\twoheadrightarrow_R$ to be its reflexive, transitive closure.

\begin{code}
  data _⇒_ : Relation where
    redex : ∀ {V} {K} {C : Kind (-Constructor K)} {c : Constructor C} {EE : Subexpression V (-Constructor K) C} {F : Expression V K} → R c EE F → app c EE ⇒ F
    app : ∀ {V} {K} {C : Kind (-Constructor K)} {c : Constructor C} {MM NN : Subexpression V (-Constructor K) C} → MM ⇒ NN → app c MM ⇒ app c NN
    appl : ∀ {V} {K} {L} {C : Kind (-Constructor L)} {M N : Subexpression V -Abstraction K} {PP : Subexpression V (-Constructor L) C} → M ⇒ N → app₂ M PP ⇒ app₂ N PP
    appr : ∀ {V} {K} {L} {C : Kind (-Constructor L)} {M : Subexpression V -Abstraction K} {NN PP : Subexpression V (-Constructor L) C} → NN ⇒ PP → app₂ M NN ⇒ app₂ M PP
    out : ∀ {V} {K} {M N : Expression V K} → M ⇒ N → out M ⇒ out N
    Λ : ∀ {V} {K} {L} {M N : Subexpression (V , K) -Abstraction L} → M ⇒ N → Λ M ⇒ Λ N

  data _↠_ {V} {C} {K} : Subexpression V C K → Subexpression V C K → Set  where
    osr-red : ∀ {M} {N} → M ⇒ N → M ↠ N
    ref : ∀ {M} → M ↠ M
    trans-red : ∀ {M} {N} {P} → M ↠ N → N ↠ P → M ↠ P

  redapp : ∀ {V} {K} {C : Kind (-Constructor K)} (c : Constructor C) {E F : Subexpression V (-Constructor K) C} →
    E ↠ F → app c E ↠ app c F
  redapp _ (osr-red E→F) = osr-red (app E→F)
  redapp _ ref = ref
  redapp c (trans-red E↠F F↠G) = trans-red (redapp c E↠F) (redapp c F↠G)

  redappl : ∀ {V} {K} {L} {C : Kind (-Constructor L)} {A B : Subexpression V -Abstraction K} {EE : Subexpression V (-Constructor L) C} →
    A ↠ B → app₂ A EE ↠ app₂ B EE
  redappl (osr-red A→B) = osr-red (appl A→B)
  redappl ref = ref
  redappl (trans-red A↠B B↠C) = trans-red (redappl A↠B) (redappl B↠C)

  redappr : ∀ {V} {K} {L} {C : Kind (-Constructor L)} {A : Subexpression V -Abstraction K} {EE FF : Subexpression V (-Constructor L) C} →
    EE ↠ FF → app₂ A EE ↠ app₂ A FF
  redappr (osr-red EE→FF) = osr-red (appr EE→FF)
  redappr ref = ref
  redappr (trans-red EE↠FF FF↠GG) = trans-red (redappr EE↠FF) (redappr FF↠GG)

  redout : ∀ {V} {K} {E F : Expression V K} → E ↠ F → out E ↠ out F
  redout (osr-red E→F) = osr-red (out E→F)
  redout ref = ref
  redout (trans-red E↠F F↠G) = trans-red (redout E↠F) (redout F↠G)

  redΛ : ∀ {V} {K} {L} {A B : Subexpression (V , K) -Abstraction L} → A ↠ B → Λ A ↠ Λ B
  redΛ (osr-red A→B) = osr-red (Λ A→B)
  redΛ ref = ref
  redΛ (trans-red A↠B B↠C) = trans-red (redΛ A↠B) (redΛ B↠C)
\end{code}

We define $\simeq_R$ to be the reflexive, symmetric, transitive closure of $\rightarrow_R$.  We say $M$ and $N$ are \emph{$R$-convertible} iff $M \simeq_R N$.

\begin{code}
  data _≃_ {V} {C} {K} : Subexpression V C K → Subexpression V C K → Set where
    osr-conv : ∀ {M} {N} → M ⇒ N → M ≃ N
    ref : ∀ {M} → M ≃ M
    sym-conv : ∀ {M} {N} → M ≃ N → N ≃ M
    trans-conv : ∀ {M} {N} {P} → M ≃ N → N ≃ P → M ≃ P
\end{code}

\begin{definition}
Let $\rhd$ be a relation between expressions such that, whenever $M \rhd N$, then $M$ and $N$ have the same kind.  Let $Op$ be a family of operators.
\begin{enumerate}
\item
We say $\rhd$  \emph{respects} $Op$ iff, for all $\sigma \in Op$, whenever $M \rhd N$, then $\sigma[M] \rhd \sigma[N]$.
\item
We say $\rhd$  \emph{creates} $Op$ iff, whenever $\rho[M] \rhd N$, then there exists $P$ such that $M \rhd P$ and $\sigma[P] \equiv N$.
\end{enumerate}
\end{definition}

\begin{code}
  module Respects-Creates (Ops : OpFamily) where
    open OpFamily Ops

    respects : Relation → Set
    respects _▷_ = ∀ {U} {V} {C} {K} {M N : Subexpression U C K} {σ : Op U V} → M ▷ N → ap σ M ▷ ap σ N

    respects' : Set
    respects' = ∀ {U} {V} {C} {K} {c} {M} {N} {σ} → R {U} {C} {K} c M N → R {V} {C} {K} c (ap σ M) (ap σ N)

    record creation (_▷_ : Relation) {U} {V} {C} {K} (M : Subexpression U C K) {N} {σ : Op U V} (δ : ap σ M ▷ N) : Set where
      field
        created : Subexpression U C K
        red-created : M ▷ created
        ap-created : ap σ created ≡ N

    creates : Relation → Set
    creates ▷ = ∀ {U} {V} {C} {K} M {N} {σ} δ → creation ▷ {U} {V} {C} {K} M {N} {σ} δ

    record creation' {U} {V} {C} {K} {c} M {N} {σ : Op U V} (δ : R {V} {C} {K} c (ap σ M) N) : Set where
      field
        created : Expression U C
        red-created : R c M created
        ap-created : ap σ created ≡ N

    creates' : Set
    creates' = ∀ {U} {V} {C} {K} {c} M {N} {σ} δ → creation' {U} {V} {C} {K} {c} M {N} {σ} δ
\end{code}

\begin{lemma}
If $R$ respects $Op$, then so do $\rightarrow_R$, $\twoheadrightarrow_R$ and $\simeq_R$.
\end{lemma}

\begin{code}
    respects-osr : respects' → respects _⇒_
    respects-osr hyp (redex M▷N) = redex (hyp M▷N)
    respects-osr hyp (app MM→NN) = app (respects-osr hyp MM→NN)
    respects-osr hyp (appl M→N) = appl (respects-osr hyp M→N)
    respects-osr hyp (appr NN→PP) = appr (respects-osr hyp NN→PP)
    respects-osr hyp (out M→N) = out (respects-osr hyp M→N)
    respects-osr hyp (Λ M→N) = Λ (respects-osr hyp M→N)

    respects-red : respects' → respects _↠_
    respects-red hyp (osr-red M→N) = osr-red (respects-osr hyp M→N)
    respects-red _ ref = ref
    respects-red hyp (trans-red M↠N N↠P) = trans-red (respects-red hyp M↠N) (respects-red hyp N↠P)

    respects-conv : respects' → respects _≃_
    respects-conv hyp (osr-conv M→N) = osr-conv (respects-osr hyp M→N)
    respects-conv _ ref = ref
    respects-conv hyp (sym-conv M≃N) = sym-conv (respects-conv hyp M≃N)
    respects-conv hyp (trans-conv M≃N N≃P) = trans-conv (respects-conv hyp M≃N) (respects-conv hyp N≃P)
\end{code}

Let $\sigma, \tau : U \Rightarrow V$.  We say that $\sigma$ \emph{reduces} to $\tau$, $\sigma \twoheadrightarrow_R \tau$,
iff $\sigma(x) \twoheadrightarrow_R \tau(x)$ for all $x$.

\begin{code}
    _↠s_ : ∀ {U} {V} → Op U V → Op U V → Set
    _↠s_ {U} {V} σ τ = ∀ K (x : Var U K) → apV σ x ↠ apV τ x
\end{code}

\begin{lemma}
\begin{enumerate}
\item
If $R$ respects $Ops$ and $\sigma \twoheadrightarrow_R \tau$ then $(\sigma , K) \twoheadrightarrow_R (\tau , K)$.
\item
If $R$ respects $Ops$ and $\sigma \twoheadrightarrow_R \tau$ then $E[\sigma] \twoheadrightarrow_R E[\tau]$.
\end{enumerate}
\end{lemma}

\begin{code}
    liftSub-red : ∀ {U} {V} {K} {ρ σ : Op U V} → respects' → ρ ↠s σ → liftOp K ρ ↠s liftOp K σ
    liftSub-red _ _ _ x₀ = subst2 _↠_ (sym liftOp-x₀) (sym liftOp-x₀) ref
    liftSub-red hyp ρ↠σ K (Taxonomy.↑ x) = subst2 _↠_ (sym (liftOp-↑ x)) (sym (liftOp-↑ x)) (respects-red hyp (ρ↠σ K x))

    apredl : ∀ {U} {V} {C} {K} {ρ σ : Op U V} {E : Subexpression U C K} → respects' → ρ ↠s σ → ap ρ E ↠ ap σ E
    apredl {E = var x} hyp ρ↠σ = ρ↠σ _ x
    apredl {E = app c E} hyp ρ↠σ = redapp c (apredl {E = E} hyp ρ↠σ)
    apredl {E = out E} hyp ρ↠σ = redout (apredl {E = E} hyp ρ↠σ)
    apredl {E = Λ E} hyp ρ↠σ = redΛ (apredl {E = E} hyp (liftSub-red hyp ρ↠σ))
    apredl {E = out₂} _ _ = ref
    apredl {E = app₂ E F} hyp ρ↠σ = trans-red (redappl (apredl {E = E} hyp ρ↠σ)) (redappr (apredl {E = F} hyp ρ↠σ))
\end{code}

\begin{lemma}
If $R$ creates replacements, then so do $\rightarrow_R$, $\twoheadrightarrow_R$ and $\simeq_R$.
\end{lemma}

\begin{code}
  create-osr : Respects-Creates.creates' replacement → Respects-Creates.creates replacement _⇒_
  create-osr _ (var _) ()
  create-osr hyp (ToGrammar.app c E) (redex cσE→F) =
    let open Respects-Creates.creation' replacement (hyp E cσE→F) in
    record { 
      created = created;
      red-created = redex red-created;
      ap-created = ap-created }
  create-osr hyp (ToGrammar.app c E) (app δ) = 
    let open Respects-Creates.creation replacement (create-osr hyp E δ) in 
    record { 
      created = app c created; 
      red-created = app red-created; 
      ap-created = wd (app c) ap-created }
  create-osr hyp (out E) (out δ) = 
    let open Respects-Creates.creation replacement (create-osr hyp E δ) in 
    record { 
      created = out created; 
      red-created = out red-created; 
      ap-created = wd out ap-created }
  create-osr hyp (Λ E) (Λ δ) = 
    let open Respects-Creates.creation replacement (create-osr hyp E δ) in 
    record { 
      created = Λ created; 
      red-created = Λ red-created; 
      ap-created = wd Λ ap-created }
  create-osr _ out₂ ()
  create-osr hyp (ToGrammar.app₂ E F) {σ = σ} (appl δ) = 
    let open Respects-Creates.creation replacement (create-osr hyp E δ) in 
    record { 
      created = app₂ created F; 
      red-created = appl red-created; 
      ap-created = wd (λ x → app₂ x (F 〈 σ 〉)) ap-created }
  create-osr hyp (ToGrammar.app₂ E F) {σ = σ} (appr δ) = 
    let open Respects-Creates.creation replacement (create-osr hyp F δ) in 
    record { 
      created = app₂ E created; 
      red-created = appr red-created; 
      ap-created = wd (app₂ (E 〈 σ 〉)) ap-created }
\end{code}

\subsection{Strong Normalization}

The \emph{strongly normalizable} expressions are defined inductively as follows.

\begin{code}
  data SN {V} {C} {K} : Subexpression V C K → Set where
    SNI : ∀ E → (∀ F → E ⇒ F → SN F) → SN E
\end{code}

\begin{lemma}
\begin{enumerate}
\item
If $c([\vec{x_1}]E_1, \ldots, [\vec{x_n}]E_n)$ is strongly normalizable, then each $E_i$ is strongly normalizable.
\item
If $E[\sigma]$ is strongly normalizable and $R$ respects substitution then $E$ is strongly normalizable.
\item
If $E$ is strongly normalizable and $E \twoheadrightarrow_R F$ then $F$ is strongly normalizable.
\end{enumerate}
\end{lemma}

\begin{code}
  SNsubexp : ∀ {V} {K} {C : Kind (-Constructor K)} {c : Constructor C} {EE : Subexpression V (-Constructor K) C} → SN (app c EE) → SN EE
  SNsubexp {c = c} {EE = EE} (SNI .(app c EE) SNcEE) = SNI EE (λ FF EE→FF → SNsubexp (SNcEE (app c FF) (app EE→FF)))

  SNout : ∀ {V} {K} → SN {V = V} {C = -Constructor K} out₂
  SNout = SNI out₂ (λ _ ())

  SNsubbodyl : ∀ {V} {K} {L} {C : Kind (-Constructor K)} {A : Subexpression V -Abstraction L} {EE : Subexpression V (-Constructor K) C} →
    SN (app₂ A EE) → SN A
  SNsubbodyl {A = A} {EE = EE} (SNI .(app₂ A EE) SNEE) = SNI A (λ B A↠B → SNsubbodyl (SNEE (app₂ B EE) (appl A↠B)))

  SNsubbodyr : ∀ {V} {K} {L} {C : Kind (-Constructor K)} {A : Subexpression V -Abstraction L} {EE : Subexpression V (-Constructor K) C} →
    SN (app₂ A EE) → SN EE
  SNsubbodyr {A = A} {EE = EE} (SNI .(app₂ A EE) SNEE) = SNI EE (λ FF EE↠FF → SNsubbodyr (SNEE (app₂ A FF) (appr EE↠FF)))

  SNoutA : ∀ {V} {K} {E : Expression V K} → SN (out E) → SN E
  SNoutA {E = E} (SNI .(out E) SNE) = SNI E (λ F E→F → SNoutA (SNE (out F) (out E→F)))
  
  SNlam : ∀ {V} {K} {L} {A : Subexpression (V , K) -Abstraction L} → SN (Λ A) → SN A
  SNlam {A = A} (SNI .(Λ A) SNlamA) = SNI A (λ B A→B → SNlam (SNlamA (Λ B) (Λ A→B)))

  SNap' : ∀ {Ops : OpFamily} {U} {V} {C} {K} {E : Subexpression U C K} {σ : OpFamily.Op Ops U V} →
    Respects-Creates.respects' Ops → SN (OpFamily.ap Ops σ E) → SN E
  SNap' {Ops} {E = E} {σ = σ} hyp (SNI .(OpFamily.ap Ops σ E) SNσE) = SNI E (λ F E→F → SNap' {Ops} hyp (SNσE (OpFamily.ap Ops σ F) 
    (Respects-Creates.respects-osr Ops hyp E→F)))

  SNap : ∀ {U} {V} {C} {K} {E : Subexpression U C K} {σ : Rep U V} →
    Respects-Creates.creates' replacement → SN E → SN (E 〈 σ 〉)
  SNap {U} {V} {C} {K} {E} {σ} hyp (SNI .E SNE) = SNI (E 〈 σ 〉) (λ F σE→F → 
    let E₀ = create-osr hyp E σE→F in
    let open Respects-Creates.creation replacement E₀ in
    subst SN ap-created (SNap hyp (SNE created red-created)))

  SNred : ∀ {V} {K} {E F : Expression V K} → SN E → E ↠ F → SN F
  SNred {V} {K} {E} {F} (SNI .E SNE) (osr-red E→F) = SNE F E→F
  SNred SNE ref = SNE
  SNred SNE (trans-red E↠F F↠G) = SNred (SNred SNE E↠F) F↠G
\end{code}
