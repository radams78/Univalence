\begin{code}
open import Prelims
open import Grammar
module Reduction (G : Grammar) where
  open Grammar.Grammar G 
\end{code}

\section{Reduction}

A \emph{reduction relation} is a relation $R$ between expressions such that, whenever $M R N$, then $M$ and $N$ have the same expression kind,
and $M$ is not a variable.

\begin{code}
  Reduction : Set₁
  Reduction = ∀ {V} {K} {C : Kind (-Constructor K)} → Constructor C → Subexpression V (-Constructor K) C → Expression V K → Set
\end{code}

We define $\rightarrow_R$ to be the
congruence generated by $R$, and $\twoheadrightarrow_R$ to be its reflexive, transitive closure.

\begin{code}
  data osr (R : Reduction) : ∀ {V} {C} {K} → Subexpression V C K → Subexpression V C K → Set where
    redex : ∀ {V} {K} {C : Kind (-Constructor K)} {c : Constructor C} {EE : Subexpression V (-Constructor K) C} {F : Expression V K} → R c EE F → osr R (app c EE) F
    app : ∀ {V} {K} {C : Kind (-Constructor K)} {c : Constructor C} {MM NN : Subexpression V (-Constructor K) C} → osr R MM NN → osr R (app c MM) (app c NN)
    appl : ∀ {V} {K} {L} {C : Kind (-Constructor L)} {M N : Subexpression V -Abstraction K} {PP : Subexpression V (-Constructor L) C} → osr R M N → osr R (app₂ M PP) (app₂ N PP)
    appr : ∀ {V} {K} {L} {C : Kind (-Constructor L)} {M : Subexpression V -Abstraction K} {NN PP : Subexpression V (-Constructor L) C} → osr R NN PP → osr R (app₂ M NN) (app₂ M PP)
    out : ∀ {V} {K} {M N : Expression V K} → osr R M N → osr R (out M) (out N)
    Λ : ∀ {V} {K} {L} {M N : Subexpression (V , K) -Abstraction L} → osr R M N → osr R (Λ M) (Λ N)

  _→〈_〉_ : ∀ {V} {C} {K} → Subexpression V C K → Reduction → Subexpression V C K → Set
  M →〈 R 〉 N = osr R M N

  data red (R : Reduction) {V} {C} {K} : Subexpression V C K → Subexpression V C K → Set where
    osr-red : ∀ {M} {N} → M →〈 R 〉 N → red R M N
    ref : ∀ {M} → red R M M
    trans-red : ∀ {M} {N} {P} → red R M N → red R N P → red R M P

  _↠〈_〉_ : ∀ {V} {C} {K} → Subexpression V C K → Reduction → Subexpression V C K → Set
  M ↠〈 R 〉 N = red R M N

  redapp : ∀ {R : Reduction} {V} {K} {C : Kind (-Constructor K)} (c : Constructor C) {E F : Subexpression V (-Constructor K) C} →
    E ↠〈 R 〉 F → app c E ↠〈 R 〉 app c F
  redapp _ (osr-red E→F) = osr-red (app E→F)
  redapp _ ref = ref
  redapp c (trans-red E↠F F↠G) = trans-red (redapp c E↠F) (redapp c F↠G)

  redappl : ∀ {R : Reduction} {V} {K} {L} {C : Kind (-Constructor L)} {A B : Subexpression V -Abstraction K} {EE : Subexpression V (-Constructor L) C} →
    A ↠〈 R 〉 B → app₂ A EE ↠〈 R 〉 app₂ B EE
  redappl (osr-red A→B) = osr-red (appl A→B)
  redappl ref = ref
  redappl (trans-red A↠B B↠C) = trans-red (redappl A↠B) (redappl B↠C)

  redappr : ∀ {R : Reduction} {V} {K} {L} {C : Kind (-Constructor L)} {A : Subexpression V -Abstraction K} {EE FF : Subexpression V (-Constructor L) C} →
    EE ↠〈 R 〉 FF → app₂ A EE ↠〈 R 〉 app₂ A FF
  redappr (osr-red EE→FF) = osr-red (appr EE→FF)
  redappr ref = ref
  redappr (trans-red EE↠FF FF↠GG) = trans-red (redappr EE↠FF) (redappr FF↠GG)

  redout : ∀ {R : Reduction} {V} {K} {E F : Expression V K} → E ↠〈 R 〉 F → out E ↠〈 R 〉 out F
  redout (osr-red E→F) = osr-red (out E→F)
  redout ref = ref
  redout (trans-red E↠F F↠G) = trans-red (redout E↠F) (redout F↠G)

  redΛ : ∀ {R : Reduction} {V} {K} {L} {A B : Subexpression (V , K) -Abstraction L} → A ↠〈 R 〉 B → Λ A ↠〈 R 〉 Λ B
  redΛ (osr-red A→B) = osr-red (Λ A→B)
  redΛ ref = ref
  redΛ (trans-red A↠B B↠C) = trans-red (redΛ A↠B) (redΛ B↠C)
\end{code}

We define $\simeq_R$ to be the reflexive, symmetric, transitive closure of $\rightarrow_R$.  We say $M$ and $N$ are \emph{$R$-convertible} iff $M \simeq_R N$.

\begin{code}
  data conv (R : Reduction) {V} {C} {K} : Subexpression V C K → Subexpression V C K → Set where
    osr-conv : ∀ {M} {N} → M →〈 R 〉 N → conv R M N
    ref : ∀ {M} → conv R M M
    sym-conv : ∀ {M} {N} → conv R M N → conv R N M
    trans-conv : ∀ {M} {N} {P} → conv R M N → conv R N P → conv R M P

  _≃〈_〉_ : ∀ {V} {C} {K} → Subexpression V C K → Reduction → Subexpression V C K → Set
  M ≃〈 R 〉 N = conv R M N
\end{code}

\begin{definition}
Let $\rhd$ be a relation between expressions such that, whenever $M \rhd N$, then $M$ and $N$ have the same kind.  Let $Op$ be a family of operators.
\begin{enumerate}
\item
We say $\rhd$  \emph{respects} $Op$ iff, for all $\sigma \in Op$, whenever $M \rhd N$, then $\sigma[M] \rhd \sigma[N]$.
\item
We say $\rhd$  \emph{creates} $Op$ iff, whenever $\rho[M] \rhd N$, then there exists $P$ such that $M \rhd P$ and $\sigma[P] \equiv N$.
\end{enumerate}
\end{definition}

\begin{code}
  module Respects-Creates (Ops : OpFamily) where
    open OpFamily Ops

    Relation : Set₁
    Relation = ∀ {V} {C} {K} → Subexpression V C K → Subexpression V C K → Set

    respects : Relation → Set
    respects R = ∀ {U} {V} {C} {K} {M N : Subexpression U C K} {σ : Op U V} → R M N → R (ap σ M) (ap σ N)

    respects' : Reduction → Set
    respects' R = ∀ {U} {V} {C} {K} {c} {M} {N} {σ} → R {U} {C} {K} c M N → R {V} {C} {K} c (ap σ M) (ap σ N)

    record creation (R : Relation) {U} {V} {C} {K} (M : Subexpression U C K) {N} {σ : Op U V} (δ : R (ap σ M) N) : Set where
      field
        created : Subexpression U C K
        red-created : R M created
        ap-created : ap σ created ≡ N

    creates : Relation → Set
    creates R = ∀ {U} {V} {C} {K} M {N} {σ} δ → creation R {U} {V} {C} {K} M {N} {σ} δ

    record creation' (R : Reduction) {U} {V} {C} {K} {c} M {N} {σ : Op U V} (δ : R {V} {C} {K} c (ap σ M) N) : Set where
      field
        created : Expression U C
        red-created : R c M created
        ap-created : ap σ created ≡ N

    creates' : Reduction → Set
    creates' R = ∀ {U} {V} {C} {K} {c} M {N} {σ} δ → creation' R {U} {V} {C} {K} {c} M {N} {σ} δ
--TODO Refactor
\end{code}

\begin{lemma}
If $R$ respects $Op$, then so do $\rightarrow_R$, $\twoheadrightarrow_R$ and $\simeq_R$.
\end{lemma}

\begin{code}
    respects-osr : ∀ {R : Reduction} → respects' R → respects (osr R)
    respects-osr hyp (redex M▷N) = redex (hyp M▷N)
    respects-osr hyp (app MM→NN) = app (respects-osr hyp MM→NN)
    respects-osr hyp (appl M→N) = appl (respects-osr hyp M→N)
    respects-osr hyp (appr NN→PP) = appr (respects-osr hyp NN→PP)
    respects-osr hyp (out M→N) = out (respects-osr hyp M→N)
    respects-osr hyp (Λ M→N) = Λ (respects-osr hyp M→N)

    respects-red : ∀ {R : Reduction} → respects' R → respects (red R)
    respects-red hyp (osr-red M→N) = osr-red (respects-osr hyp M→N)
    respects-red _ ref = ref
    respects-red hyp (trans-red M↠N N↠P) = trans-red (respects-red hyp M↠N) (respects-red hyp N↠P)

    respects-conv : ∀ {R : Reduction} → respects' R → respects (conv R)
    respects-conv hyp (osr-conv M→N) = osr-conv (respects-osr hyp M→N)
    respects-conv _ ref = ref
    respects-conv hyp (sym-conv M≃N) = sym-conv (respects-conv hyp M≃N)
    respects-conv hyp (trans-conv M≃N N≃P) = trans-conv (respects-conv hyp M≃N) (respects-conv hyp N≃P)
\end{code}

Let $\sigma, \tau : U \Rightarrow V$.  We say that $\sigma$ \emph{reduces} to $\tau$, $\sigma \twoheadrightarrow_R \tau$,
iff $\sigma(x) \twoheadrightarrow_R \tau(x)$ for all $x$.

\begin{code}
    _↠〈_〉s_ : ∀ {U} {V} → Op U V → Reduction → Op U V → Set
    _↠〈_〉s_ {U} {V} σ R τ = ∀ K (x : Var U K) → apV σ x ↠〈 R 〉 apV τ x
\end{code}

\begin{lemma}
\begin{enumerate}
\item
If $R$ respects $Ops$ and $\sigma \twoheadrightarrow_R \tau$ then $(\sigma , K) \twoheadrightarrow_R (\tau , K)$.
\item
If $R$ respects $Ops$ and $\sigma \twoheadrightarrow_R \tau$ then $E[\sigma] \twoheadrightarrow_R E[\tau]$.
\end{enumerate}
\end{lemma}

\begin{code}
    liftSub-red : ∀ {U} {V} {K} {ρ σ : Op U V} {R : Reduction} → 
      respects' R → ρ ↠〈 R 〉s σ → liftOp K ρ ↠〈 R 〉s liftOp K σ
    liftSub-red {R = R} _ _ _ x₀ = subst2 (red R) (sym liftOp-x₀) (sym liftOp-x₀) ref
    liftSub-red {R = R} hyp ρ↠σ K (Taxonomy.↑ x) = subst2 (red R) (sym (liftOp-↑ x)) (sym (liftOp-↑ x)) (respects-red hyp (ρ↠σ K x))

    apredl : ∀ {U} {V} {C} {K} {ρ σ : Op U V} {E : Subexpression U C K} {R : Reduction} → respects' R → ρ ↠〈 R 〉s σ → ap ρ E ↠〈 R 〉 ap σ E
    apredl {E = var x} hyp ρ↠σ = ρ↠σ _ x
    apredl {E = app c E} hyp ρ↠σ = redapp c (apredl {E = E} hyp ρ↠σ)
    apredl {E = out E} hyp ρ↠σ = redout (apredl {E = E} hyp ρ↠σ)
    apredl {E = Λ E} hyp ρ↠σ = redΛ (apredl {E = E} hyp (liftSub-red hyp ρ↠σ))
    apredl {E = out₂} _ _ = ref
    apredl {E = app₂ E F} hyp ρ↠σ = trans-red (redappl (apredl {E = E} hyp ρ↠σ)) (redappr (apredl {E = F} hyp ρ↠σ))
\end{code}

\begin{lemma}
If $R$ creates replacements, then so do $\rightarrow_R$, $\twoheadrightarrow_R$ and $\simeq_R$.
\end{lemma}

\begin{code}
  create-osr : ∀ {R : Reduction} → Respects-Creates.creates' replacement R → ∀ {U} {V} {C} {K} (M : Subexpression U C K) {N} {σ : Rep U V} (δ : M 〈 σ 〉 →〈 R 〉 N) → 
    Respects-Creates.creation replacement (osr R) M δ
  create-osr _ (var _) ()
  create-osr hyp (ToGrammar.app c E) (redex cσE→F) =
    let open Respects-Creates.creation' replacement (hyp E cσE→F) in
    record { 
      created = created;
      red-created = redex red-created;
      ap-created = ap-created }
  create-osr hyp (ToGrammar.app c E) (app δ) = 
    let open Respects-Creates.creation replacement (create-osr hyp E δ) in 
    record { 
      created = app c created; 
      red-created = app red-created; 
      ap-created = wd (app c) ap-created }
  create-osr hyp (out E) (out δ) = 
    let open Respects-Creates.creation replacement (create-osr hyp E δ) in 
    record { 
      created = out created; 
      red-created = out red-created; 
      ap-created = wd out ap-created }
  create-osr hyp (Λ E) (Λ δ) = 
    let open Respects-Creates.creation replacement (create-osr hyp E δ) in 
    record { 
      created = Λ created; 
      red-created = Λ red-created; 
      ap-created = wd Λ ap-created }
  create-osr _ out₂ ()
  create-osr hyp (ToGrammar.app₂ E F) {σ = σ} (appl δ) = 
    let open Respects-Creates.creation replacement (create-osr hyp E δ) in 
    record { 
      created = app₂ created F; 
      red-created = appl red-created; 
      ap-created = wd (λ x → app₂ x (F 〈 σ 〉)) ap-created }
  create-osr hyp (ToGrammar.app₂ E F) {σ = σ} (appr δ) = 
    let open Respects-Creates.creation replacement (create-osr hyp F δ) in 
    record { 
      created = app₂ E created; 
      red-created = appr red-created; 
      ap-created = wd (app₂ (E 〈 σ 〉)) ap-created }
\end{code}

\subsection{Strong Normalization}

The \emph{strongly normalizable} expressions are defined inductively as follows.

\begin{code}
  data SN (R : Reduction) {V} {C} {K} : Subexpression V C K → Set where
    SNI : ∀ E → (∀ F → E →〈 R 〉 F → SN R F) → SN R E
\end{code}

\begin{lemma}
\begin{enumerate}
\item
If $c([\vec{x_1}]E_1, \ldots, [\vec{x_n}]E_n)$ is strongly normalizable, then each $E_i$ is strongly normalizable.
\item
If $E[\sigma]$ is strongly normalizable and $R$ respects substitution then $E$ is strongly normalizable.
\item
If $E$ is strongly normalizable and $E \twoheadrightarrow_R F$ then $F$ is strongly normalizable.
\end{enumerate}
\end{lemma}

\begin{code}
  SNsubexp : ∀ {V} {K} {C : Kind (-Constructor K)} {c : Constructor C} {EE : Subexpression V (-Constructor K) C} {R : Reduction} → SN R (app c EE) → SN R EE
  SNsubexp {c = c} {EE = EE} (SNI .(app c EE) SNcEE) = SNI EE (λ FF EE→FF → SNsubexp (SNcEE (app c FF) (app EE→FF)))

  SNout : ∀ {V} {K} {R : Reduction} → SN R {V = V} {C = -Constructor K} out₂
  SNout = SNI out₂ (λ _ ())

  SNsubbodyl : ∀ {V} {K} {L} {C : Kind (-Constructor K)} {A : Subexpression V -Abstraction L} {EE : Subexpression V (-Constructor K) C} {R : Reduction} →
    SN R (app₂ A EE) → SN R A
  SNsubbodyl {A = A} {EE = EE} (SNI .(app₂ A EE) SNEE) = SNI A (λ B A↠B → SNsubbodyl (SNEE (app₂ B EE) (appl A↠B)))

  SNsubbodyr : ∀ {V} {K} {L} {C : Kind (-Constructor K)} {A : Subexpression V -Abstraction L} {EE : Subexpression V (-Constructor K) C} {R : Reduction} →
    SN R (app₂ A EE) → SN R EE
  SNsubbodyr {A = A} {EE = EE} (SNI .(app₂ A EE) SNEE) = SNI EE (λ FF EE↠FF → SNsubbodyr (SNEE (app₂ A FF) (appr EE↠FF)))

  SNoutA : ∀ {V} {K} {R : Reduction} {E : Expression V K} → SN R (out E) → SN R E
  SNoutA {E = E} (SNI .(out E) SNE) = SNI E (λ F E→F → SNoutA (SNE (out F) (out E→F)))
  
  SNlam : ∀ {V} {K} {L} {R : Reduction} {A : Subexpression (V , K) -Abstraction L} → SN R (Λ A) → SN R A
  SNlam {A = A} (SNI .(Λ A) SNlamA) = SNI A (λ B A→B → SNlam (SNlamA (Λ B) (Λ A→B)))

  SNap' : ∀ {Ops : OpFamily} {U} {V} {C} {K} {E : Subexpression U C K} {σ : OpFamily.Op Ops U V} {R : Reduction} →
    Respects-Creates.respects' Ops R → SN R (OpFamily.ap Ops σ E) → SN R E
  SNap' {Ops} {E = E} {σ = σ} hyp (SNI .(OpFamily.ap Ops σ E) SNσE) = SNI E (λ F E→F → SNap' {Ops} hyp (SNσE (OpFamily.ap Ops σ F) 
    (Respects-Creates.respects-osr Ops hyp E→F)))

  SNap : ∀ {U} {V} {C} {K} {E : Subexpression U C K} {σ : Rep U V} {R : Reduction} →
    Respects-Creates.creates' replacement R → SN R E → SN R (E 〈 σ 〉)
  SNap {U} {V} {C} {K} {E} {σ} {R} hyp (SNI .E SNE) = SNI (E 〈 σ 〉) (λ F σE→F → 
    let E₀ = create-osr hyp E σE→F in
    let open Respects-Creates.creation replacement E₀ in
    subst (SN R) ap-created (SNap hyp (SNE created red-created)))

  SNred : ∀ {V} {K} {E F : Expression V K} {R : Reduction} → SN R E → E ↠〈 R 〉 F → SN R F
  SNred {V} {K} {E} {F} (SNI .E SNE) (osr-red E→F) = SNE F E→F
  SNred SNE ref = SNE
  SNred SNE (trans-red E↠F F↠G) = SNred (SNred SNE E↠F) F↠G
\end{code}
