\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{fancyvrb}
\usepackage{proof}
\usepackage{stmaryrd}

\DeclareUnicodeCharacter{8598}{\ensuremath{\nwarrow}}
\DeclareUnicodeCharacter{8599}{\ensuremath{\nearrow}}
\DeclareUnicodeCharacter{8608}{\ensuremath{\twoheadrightarrow}}
\DeclareUnicodeCharacter{8657}{\ensuremath{\Uparrow}}
\DeclareUnicodeCharacter{8667}{\ensuremath{\Rrightarrow}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\qed}}
\DeclareUnicodeCharacter{8759}{\ensuremath{::}}
\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
\DeclareUnicodeCharacter{9001}{\ensuremath{\langle}}
\DeclareUnicodeCharacter{9002}{\ensuremath{\rangle}}
\DeclareUnicodeCharacter{9655}{\ensuremath{\rhd}}
\DeclareUnicodeCharacter{10214}{\ensuremath{[}}
\DeclareUnicodeCharacter{10215}{\ensuremath{]}}
\DeclareUnicodeCharacter{10219}{\ensuremath{\rangle\rangle}}


\usepackage{textalpha}

\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\footnotesize}

% \newtheorem{lemma}{Lemma}[section]
% \newtheorem{corollary}[lemma]{Corollary}
\newtheorem{prop}{Proposition}[section]
% \newtheorem{theorem}{Theorem}[section]
% \theoremstyle{definition}
% \newtheorem{definition}[lemma]{Definition}

\newcommand{\Set}{\mathbf{Set}}
\newcommand{\eqdef}{\mathrel{\smash{\stackrel{\text{def}}{=}}}}
\newcommand{\AgdaHide}[1]{}
\newcommand{\isotoid}{\ensuremath{isotoid}}
\newcommand{\vald}{\ensuremath{\ \mathrm{valid}}}
\newcommand{\reff}[1]{\ensuremath{\mathsf{ref} \left( {#1} \right)}}
\newcommand{\univ}[4]{\ensuremath{\mathsf{univ}_{{#1} , {#2}} \left( {#3} , {#4} \right)}}
\newcommand{\triplelambda}{\lambda \!\! \lambda \!\! \lambda}
\newcommand{\SN}{\mathbf{SN}}

\begin{document}

\begin{frame}
\maketitle

\mode<beamer>{
\begin{small}
\begin{center}
This talk is a literate Agda file
\texttt{https://github.com/radams78/Univalence}
\end{center}
\end{small}
}

%TODO Full author and conference information

\end{frame}

\section{Introduction}

\begin{frame}
\frametitle{Type Theory Orthoodoxy}
\begin{itemize}[<+->]
\item
To enjoy a good meaning explanation, a type theory should enjoy these properties:
\begin{itemize}
\item \textbf{Confluence} --- Reduction is confluent.
\item \textbf{Strong Normalization} --- Every reduction strategy terminates.
\item \textbf{Canonicity} --- Hence every well-typed term of type $A$ reduces to a unique canonical form of $A$.
\begin{itemize}
\item
E.g. every closed term of type $\mathbb{N}$ reduces to a unique numeral.
\end{itemize}
\end{itemize}
\item 
The \emph{univalence axiom} postulates a function
\[ \isotoid : A \simeq B \rightarrow A = B \]
that is an inverse to the obvious function $A = B \rightarrow A \simeq B$.
\item
This breaks canonicity.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Possible Solutions}
\begin{itemize}[<+->]
\item
Lower our standards
\begin{itemize}
\item
\textbf{Voevodsky's Conjecture --- Propositional Canonicity}

For every closed term $t : \mathbb{N}$, there exists a numeral $n$ and a proof $\vdash p : Id_\mathbb{N}(t,n)$.
\end{itemize}
\item
Use a type theory in which $\isotoid$ is definable (Cubical Type Theory, \cite{Polonsky14a}) %TODO Cite
\item
Introduce a reduction rule for $\isotoid$.
\end{itemize}
\end{frame}
%TODO Look up other possible solutions.

\begin{frame}
\frametitle{Our Approach}
We begin with a small type theory, and work our way up to the full HoTT. %Too much?
\begin{enumerate}
\item \textbf{$\lambda o e$ --- Predicative Higher-Order Propositional Logic}

 A type theory with:
  \begin{itemize}
  \item a universe $\Omega$ of \emph{propositions} with $\bot$ and $\supset$
  \item a universe $U$ of \emph{small types} with $\Omega$ and $\rightarrow$
  \item for any two terms $M, N : A$, a (large) type $M =_A N$.
  \end{itemize}
\item \textbf{$\lambda o i$ --- P.H.O.P.L. with Equality}

Make $\delta =_\phi \epsilon$ a proposition.  (So we can form propositions like $M =_A N \supset N =_A M$.)
\end{enumerate}
For the future: universal quantification, natural numbers, inductive types, path elimination, \ldots
\end{frame}
%TODO Better names

\section{About the Formalization}

\begin{frame}
\frametitle{About the Formalization}
This work is being formalized in Agda (work in progress).
\pause

It will involve several systems and reduction relations.

I want to prove only once:
\pause
\begin{itemize}[<+->]
\item
$M[x:=N][y:=P] \equiv M[y:=P[x:=N]][x:=N]$
\item
If $M \twoheadrightarrow N$ then $M[x:=P] \twoheadrightarrow N[x:=P]$
\item
If $M[x:=P]$ is SN then $M$ is SN.
\item
Etc.
\end{itemize}
\pause
The formalization includes a general notion of `grammar' and `reduction relation'.  (To do: general notion of derivation rules.)
\end{frame}

\input{Prelims.lagda}
\mode<all>{\input{Grammar/Taxonomy.lagda}}
\mode<all>{\input{Grammar/Base.lagda}}

We define the operations of replacement and substitution on
expressions.  

\input{Grammar/Substitution/PreOpFamily.lagda}
\input{Grammar/Substitution/OpFamily.lagda}

The details are given in Appendix \ref{appendix:repsub}.

\input{Grammar/Context.lagda}
\input{Reduction/Base.lagda}
\input{Reduction/SN.lagda}
\input{PL/Grammar.lagda}
\input{PL/Rules.lagda}
\input{PL/Computable.lagda}

\section{Predicative Higher-Order Propositional Logic}

\mode<all>{\input{PHOPL/Grammar.lagda}}
\mode<all>{\input{PHOPL/Rules.lagda}}

\subsection{The Reduction Relation}

\mode<all>{\input{PHOPL/Red.lagda}}

\subsection{Strong Normalization Proof}

\mode<all>{\input{PHOPL/Computable.lagda}}
\mode<all>{\input{PHOPL/MainProp1.lagda}}
\mode<all>{\input{PHOPL/MainProp.lagda}}

\section{$\lambda o i$}

\begin{frame}
\frametitle{Include equations in $\Omega$}

\begin{itemize}
\item
We can include the equations $M =_A N$ in our logic.
\onslide<2->{
\item
Now we can form (and prove) $sym_{MN} : M =_A N \supset N =_A M$ and $trans_{MNP} : M =_A N \supset N =_A P \supset M =_A P$ (by recursion on $A$).}
\end{itemize}

\[ \infer{\Gamma \vdash M =_A N : \Omega}{\Gamma \vdash M : A \quad \Gamma \vdash N : A} \]
\only<2->{\[ \infer{\Gamma \vdash \delta =^*_A \epsilon : (M =_A N) =_\Omega (M' =_A N')}
{\Gamma \vdash \delta : M =_A M' \quad \Gamma \vdash \epsilon : N =_A N'} \]}

\pause

New computation rules include:

\[ (\triplelambda^{F,G} e:x =_A y . \delta) =^* \reff{H} \]
\[ \rhd \mathsf{univ}_{F = H,G = H}(\lambda p. \triplelambda e:x=_Ay. (Gx =_{sym\ \delta} F y =_{p \reff{y}} H y), \]
\[ \lambda p. \triplelambda e:x=_A y. (F x =_{\delta} G y =_{p \reff{y}}) \]
\end{frame}

\section{Conclusion}

\begin{frame}
\frametitle{Conclusion}
\begin{itemize}[<+->]
\item
We have shown two systems that each have all these properties:
\begin{itemize}
\item
Univalence
\item
Strong Normalization
\item
Confluence of typed terms
\item
Canonicity
\end{itemize}
\item
So it is possible!
\item
The simplicity is due to the separation between terms and proofs.
\item
For the future: extract a normalizer.  Universal quantification.
\item
Follow the progress here: \url{www.github.com/radams78/Univalence}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Bibliography}
\bibliography{../../../type}
\end{frame}

\appendix

\section{Replacement and Substitution}
\label{appendix:repsub}

\input{Grammar/OpFamily/PreOpFamily.lagda}
\input{Grammar/OpFamily/Lifting.lagda}
\input{Grammar/OpFamily/LiftFamily.lagda}
\input{Grammar/OpFamily/Composition.lagda}
\input{Grammar/OpFamily/OpFamily.lagda}
\input{Grammar/Replacement.lagda}
\input{Grammar/Substitution/Lifting.lagda}
\input{Grammar/Substitution/RepSub.lagda}
\input{Grammar/Substitution/LiftFamily.lagda}
\input{Grammar/Substitution/Botsub.lagda}

\end{document}
