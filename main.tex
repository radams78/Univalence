\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{fancyvrb}
\usepackage{proof}
\usepackage{stmaryrd}

\DeclareUnicodeCharacter{8598}{\ensuremath{\nwarrow}}
\DeclareUnicodeCharacter{8599}{\ensuremath{\nearrow}}
\DeclareUnicodeCharacter{8608}{\ensuremath{\twoheadrightarrow}}
\DeclareUnicodeCharacter{8657}{\ensuremath{\Uparrow}}
\DeclareUnicodeCharacter{8667}{\ensuremath{\Rrightarrow}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\qed}}
\DeclareUnicodeCharacter{8759}{\ensuremath{::}}
\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
\DeclareUnicodeCharacter{9001}{\ensuremath{\langle}}
\DeclareUnicodeCharacter{9002}{\ensuremath{\rangle}}
\DeclareUnicodeCharacter{9655}{\ensuremath{\rhd}}
\DeclareUnicodeCharacter{10214}{\ensuremath{[}}
\DeclareUnicodeCharacter{10215}{\ensuremath{]}}
\DeclareUnicodeCharacter{10219}{\ensuremath{\rangle\rangle}}


\usepackage{textalpha}

\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}

% \newtheorem{lemma}{Lemma}[section]
% \newtheorem{corollary}[lemma]{Corollary}
\newtheorem{prop}{Proposition}[section]
% \newtheorem{theorem}{Theorem}[section]
% \theoremstyle{definition}
% \newtheorem{definition}[lemma]{Definition}

\newcommand{\Set}{\mathbf{Set}}
\newcommand{\eqdef}{\mathrel{\smash{\stackrel{\text{def}}{=}}}}
\newcommand{\AgdaHide}[1]{}
\newcommand{\isotoid}{\ensuremath{isotoid}}
\newcommand{\vald}{\ensuremath{\ \mathrm{valid}}}
\newcommand{\reff}[1]{\ensuremath{\mathsf{ref} \left( {#1} \right)}}
\newcommand{\univ}[4]{\ensuremath{\mathsf{univ}_{{#1} , {#2}} \left( {#3} , {#4} \right)}}
\newcommand{\triplelambda}{\lambda \!\! \lambda \!\! \lambda}
\newcommand{\SN}{\mathbf{SN}}

\begin{document}

\begin{frame}
\maketitle

\mode<beamer>{
\begin{small}
\begin{center}
This talk is a literate Agda file
\texttt{https://github.com/radams78/Univalence}
\end{center}
\end{small}
}

%TODO Full author and conference information

\end{frame}

\section{Introduction}

\begin{frame}
\frametitle{The problem}
\begin{itemize}[<+->]
\item
A type theory should enjoy three properties:
\begin{description}
\item[Confluence] Reduction is confluent.
\item[Strong Normalization] Every reduction strategy terminates.
\item[Canonicity] Every well-typed term of type $A$ reduces to a unique canonical form of $A$.
\end{description}
\item
E.g. every closed term of type $\mathbb{N}$ reduces to a unique numeral.
\item 
The \emph{univalence axiom} postulates a function
\[ \isotoid : A \simeq B \rightarrow A = B \]
that is an inverse to the obvious function $A = B \rightarrow A \simeq B$.
\item
This breaks canonicity.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Possible Solutions}
\begin{itemize}
\item
Lower our standards
\begin{description}
\item[Voevodsky's Conjecture]
For every closed term $t : \mathbb{N}$, there exists a numeral $n$ and a proof $\vdash p : Id_\mathbb{N}(t,n)$.
\end{description}
\item
Use a type theory in which $\isotoid$ is definable (Cubical Type Theory, \cite{Polonsky14a}) %TODO Cite
\item
Introduce a reduction rule for $\isotoid$.
\end{itemize}
\end{frame}
%TODO Look up other possible solutions.

\begin{frame}
\frametitle{Our Approach}
We begin with a small type theory, and work our way up to the full HoTT. %Too much?
\begin{enumerate}
\item \emph{Predicative Higher-Order Propositional Logic} A type theory with:
  \begin{itemize}
  \item a universe $\Omega$ of \emph{propositions} with $\bot$ and $\supset$
  \item a universe $U$ of \emph{small types} with $\Omega$ and $\rightarrow$
  \item for any two terms $M, N : A$, a (large) type $M =_A N$.
  \end{itemize}
\item \emph{PHOPL with Equality}
Make $\delta =_\phi \epsilon$ a proposition.  (So we can form propositions like $M =_A N \epsilon \supset N =_A M$.)
\item \emph{Predicative Higher-Order Predicate Logic} Close $\Omega$ under $\forall$.  (So we can form propositions like $\forall x : \phi. x =_A x$.)
\end{enumerate}
For the future: natural numbers, inductive types, path elimination, \ldots
\end{frame}

\section{About the Formalization}

\begin{frame}
\frametitle{About the Formalization}
This work is being formalized in Agda (work in progress).

It will involve several systems and reduction relations.

I want to prove only once:
\begin{itemize}
\item
$M[x:=N][y:=P] \equiv M[y:=P[x:=N]][x:=N]$
\item
If $M \twoheadrightarrow N$ then $M[x:=P] \twoheadrightarrow N[x:=P]$
\item
If $M[x:=P]$ is SN then $M$ is SN.
\item
Etc.
\end{itemize}
The formalization includes a general notion of `grammar' and `reduction relation'.  (To do: general notion of derivation rules.)

Follow the progress here: \url{www.github.com/radams78/Univalence}
\end{frame}

\input{Prelims.lagda}
\mode<all>{\input{Grammar/Taxonomy.lagda}}
\mode<all>{\input{Grammar/Base.lagda}}

We define the operations of replacement and substitution on
expressions.  The details are given in Appendix \ref{appendix:repsub}.

\input{Grammar/Context.lagda}
\input{Reduction/Base.lagda}
\input{Reduction/SN.lagda}
\input{PL/Grammar.lagda}
\input{PL/Rules.lagda}
\input{PL/Computable.lagda}

\section{Predicative Higher-Order Propositional Logic}

\input{PHOPL/Grammar.lagda}
\mode<all>{\input{PHOPL/Rules.lagda}}

\subsection{The Reduction Relation}

\mode<all>{\input{PHOPL/Red.lagda}}

\subsection{Strong Normalization Proof}

\mode<all>{\input{PHOPL/Computable.lagda}}
\mode<all>{\input{PHOPL/MainProp.lagda}}

\section{Systems Two and Three}

\begin{frame}
\frametitle{Include equations in $\Omega$}

We can include the equations $M =_A N$ in our logic.

Now we can form (and prove) $sym_{MN} : M =_A N \supset N =_A M$ and $trans_{MNP} : M =_A N \supset N =_A P \supset M =_A P$ (by recursion on $A$).

\pause

\[ \infer{\Gamma \vdash M =_A N : \Omega}{\Gamma \vdash M : A \quad \Gamma \vdash N : A} \]
\[ \infer{\Gamma \vdash \delta =^* \epsilon : (M =_A N) =_\Omega (M' =_A N')}
{\Gamma \vdash \delta : M =_A M' \quad \Gamma \vdash \epsilon : N =_A N'} \]

\pause

\[ (\delta =^* \epsilon)^+ \rhd \lambda p. trans \, \epsilon \, (trans \, p \, (sym \delta)) \]
\[ (\delta =^* \epsilon)^- \rhd \lambda p. trans \, (sym \, \epsilon) \, (trans \, p \, \delta) \]
\end{frame}

\begin{frame}
\frametitle{Universal Quantification}

We can close $\Omega$ under universal quantification in any of the types $A$ (including $\Omega$!)

\[ \infer{\Gamma \vdash \forall I (x.\delta) : \forall x : A. \phi}{\Gamma, x : A vdash \delta : \phi} \]
\[ \infer{\Gamma \vdash \forall E(\delta, M) : \phi[x:=M]} {\Gamma \vdash \delta : \forall x :A.\phi \quad \Gamma \vdash M : A} \]
\[ \infer{\Gamma \vdash \forall* x:A.\delta : \forall x:A.\phi =_\Omega \forall x:A.\psi}{\Gamma, x : A \vdash \delta : \phi =_\Omega \psi} \]

\pause

\[ (\forall^* x:A.\delta)^+ \rhd \lambda p. \forall I(x.\delta^+ \forall E(p,x)) \]
\[ (\forall^* x:A.\delta)^- \rhd \lambda p.\forall I(x.\delta^- \forall E(p,x)) \]
\end{frame}

\section{Conclusion}

\begin{frame}
\frametitle{Conclusion}
\begin{itemize}[<+->]
\item
We have shown a system that has all these properties:
\begin{itemize}
\item
Univalence
\item
Strong Normalization
\item
Confluence of typed terms
\item
Canonicity
\end{itemize}
\item
So it is possible!
\item
The simplicity is due to the separation between terms and proofs.
\item
Let's see how far we can go.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Bibliography}
\bibliography{../../../type}
\end{frame}

\appendix

\section{Replacement and Substitution}
\label{appendix:repsub}

\input{Grammar/OpFamily/PreOpFamily.lagda}
\input{Grammar/OpFamily/Lifting.lagda}
\input{Grammar/OpFamily/LiftFamily.lagda}
\input{Grammar/OpFamily/Composition.lagda}
\input{Grammar/OpFamily/OpFamily.lagda}
\input{Grammar/Replacement.lagda}
\input{Grammar/Substitution/PreOpFamily.lagda}
\input{Grammar/Substitution/Lifting.lagda}
\input{Grammar/Substitution/RepSub.lagda}
\input{Grammar/Substitution/LiftFamily.lagda}
\input{Grammar/Substitution/OpFamily.lagda}
\input{Grammar/Substitution/Botsub.lagda}

\end{document}
