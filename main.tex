\title{A Strongly Normalizing Computation Rule for Univalence in Higher-Order Propositional Logic}
\author{\alert{Robin Adams} \and Marc Bezem \and Thierry Coquand}
\date{May 26 2016}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{fancyvrb}
\usepackage{proof}
\usepackage{stmaryrd}

\DeclareUnicodeCharacter{8608}{\ensuremath{\twoheadrightarrow}}
\DeclareUnicodeCharacter{8667}{\ensuremath{\Rrightarrow}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\qed}}
\DeclareUnicodeCharacter{8759}{\ensuremath{::}}
\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
\DeclareUnicodeCharacter{9001}{\ensuremath{\langle}}
\DeclareUnicodeCharacter{9002}{\ensuremath{\rangle}}
\DeclareUnicodeCharacter{9655}{\ensuremath{\rhd}}
\DeclareUnicodeCharacter{10214}{\ensuremath{[}}
\DeclareUnicodeCharacter{10215}{\ensuremath{]}}
\DeclareUnicodeCharacter{10219}{\ensuremath{\rangle\rangle}}


\usepackage{textalpha}

\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}

% \newtheorem{lemma}{Lemma}[section]
% \newtheorem{corollary}[lemma]{Corollary}
\newtheorem{prop}{Proposition}[section]
% \newtheorem{theorem}{Theorem}[section]
% \theoremstyle{definition}
% \newtheorem{definition}[lemma]{Definition}

\newcommand{\Set}{\mathbf{Set}}
\newcommand{\eqdef}{\mathrel{\smash{\stackrel{\text{def}}{=}}}}
\newcommand{\AgdaHide}[1]{}
\newcommand{\isotoid}{\ensuremath{isotoid}}
\newcommand{\vald}{\ensuremath{\ \mathrm{valid}}}
\newcommand{\reff}[1]{\ensuremath{\mathsf{ref} \left( {#1} \right)}}
\newcommand{\univ}[4]{\ensuremath{\mathsf{univ}_{{#1} , {#2}} \left( {#3} , {#4} \right)}}
\newcommand{\triplelambda}{\lambda \!\! \lambda \!\! \lambda}

\begin{document}

\begin{frame}
\maketitle

\mode<beamer>{
\begin{small}
\begin{center}
This talk is a literate Agda file
\texttt{https://github.com/radams78/Univalence}
\end{center}
\end{small}
}

%TODO Full author and conference information

\end{frame}

\section{Introduction}

\begin{frame}
\frametitle{The problem}
\begin{itemize}
\item
A type theory should enjoy three properties:
\begin{description}
\item[Canonicity] Every well-typed term of type $A$ reduces to a canonical form of $A$.
\item[Confluence] Reduction is confluent.  (Therefore, the canonical form is unique.)
\item[Strong Normalization] Every reduction strategy terminates.
\end{description}
\item 
The \emph{univalence axiom} postulates a function
\[ \isotoid : A \simeq B \rightarrow A = B \]
that is an inverse to the obvious function $A = B \rightarrow A \simeq B$.
\item
This breaks canonicity.
\end{itemize}
\end{frame}
%TODO Define canonical form

\begin{frame}
\frametitle{Possible Solutions}
\begin{itemize}
\item
Give up.
\item
Redefine equality. %TODO Cite Polonsky
\item
Use a type theory in which $\isotoid$ is definable (e.g. Cubical Type Theory) %TODO Cite
\item
Introduce a reduction rule for $\isotoid$.
\end{itemize}
\end{frame}
%TODO Look up other possible solutions.

\begin{frame}
\frametitle{Our Approach}
We begin with a small type theory, and work our way up to the full HoTT.
\begin{enumerate}
\item \emph{Predicative Higher-Order Propositional Logic} A type theory with:
  \begin{itemize}
  \item a universe $\Omega$ of \emph{propositions} with $\bot$ and $\supset$
  \item a universe $U$ of \emph{small types} with $\Omega$ and $\rightarrow$
  \item for any two terms $M, N : A$, a (large) type $M =_A N$.
  \end{itemize}
\item \emph{PHOPL with Equality}
Make $\delta =_\phi \epsilon$ a proposition.  (So we can form propositions like $M =_A N \epsilon \supset N =_A M$.)
\item \emph{Predicative Higher-Order Predicate Logic} Close $\Omega$ under $\forall$.  (So we can form propositions like $\forall x : \phi. x =_A x$.)
\end{enumerate}
For the future: natural numbers, inductive types, path elimination, \ldots
\end{frame}

\input{Prelims.lagda}
\input{Grammar/Taxonomy.lagda}
\input{Grammar/Base.lagda}

We define the operations of replacement and substitution on
expressions.  The details are given in Appendix \ref{appendix:repsub}.

\input{Grammar/Context.lagda}
\input{Reduction/Base.lagda}
\input{Reduction/SN.lagda}
\input{PL/Grammar.lagda}
\input{PL/Rules.lagda}
\input{PL/Computable.lagda}

\section{Predicative Higher-Order Propositional Logic}

\mode<beamer>{}

\mode<all>{\input{PHOPL.lagda}}
\mode<all>{\input{PHOPL/Rules.lagda}}

\section{Systems Two and Three}

\section{Conclusion}

\appendix

\section{Replacement and Substitution}
\label{appendix:repsub}

\input{Grammar/OpFamily/PreOpFamily.lagda}
\input{Grammar/OpFamily/Lifting.lagda}
\input{Grammar/OpFamily/LiftFamily.lagda}
\input{Grammar/OpFamily/Composition.lagda}
\input{Grammar/OpFamily/OpFamily.lagda}
\input{Grammar/Replacement.lagda}
\input{Grammar/Substitution/PreOpFamily.lagda}
\input{Grammar/Substitution/Lifting.lagda}
\input{Grammar/Substitution/RepSub.lagda}
\input{Grammar/Substitution/LiftFamily.lagda}
\input{Grammar/Substitution/OpFamily.lagda}
\input{Grammar/Substitution/Botsub.lagda}

\end{document}
