\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{fancyvrb}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{todo}

\DeclareUnicodeCharacter{8598}{\ensuremath{\nwarrow}}
\DeclareUnicodeCharacter{8599}{\ensuremath{\nearrow}}
\DeclareUnicodeCharacter{8608}{\ensuremath{\twoheadrightarrow}}
\DeclareUnicodeCharacter{8657}{\ensuremath{\Uparrow}}
\DeclareUnicodeCharacter{8667}{\ensuremath{\Rrightarrow}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\qed}}
\DeclareUnicodeCharacter{8759}{\ensuremath{::}}
\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
\DeclareUnicodeCharacter{9001}{\ensuremath{\langle}}
\DeclareUnicodeCharacter{9002}{\ensuremath{\rangle}}
\DeclareUnicodeCharacter{9655}{\ensuremath{\rhd}}
\DeclareUnicodeCharacter{10214}{\ensuremath{[}}
\DeclareUnicodeCharacter{10215}{\ensuremath{]}}
\DeclareUnicodeCharacter{10219}{\ensuremath{\rangle\rangle}}

\usepackage{textalpha}

\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\footnotesize}

\newtheorem{prop}{Proposition}[section]

\newcommand{\Set}{\mathbf{Set}}
\newcommand{\eqdef}{\mathrel{\smash{\stackrel{\text{def}}{=}}}}
\newcommand{\AgdaHide}[1]{}
\newcommand{\isotoid}{\ensuremath{isotoid}}
\newcommand{\vald}{\ensuremath{\ \mathrm{valid}}}
\newcommand{\reff}[1]{\ensuremath{\mathsf{ref} \left( {#1} \right)}}
\newcommand{\univ}[4]{\ensuremath{\mathsf{univ}_{{#1} , {#2}} \left( {#3} , {#4} \right)}}
\newcommand{\triplelambda}{\lambda \!\! \lambda \!\! \lambda}
\newcommand{\SN}{\mathbf{SN}}

\begin{document}

\maketitle

\section{Introduction}

According to the traditional approach to type theory \todo{Citation}, a type theory should have the
following properties in order to enjoy a good meaning explanation:
\begin{itemize}
\item \textbf{Confluence} --- The reduction relation should be confluent.
\item \textbf{Strong Normalization} --- Every reduction strategy should terminate.
\item \textbf{Canonicity} --- Hence every well-typed term of type $A$ reduces to a unique canonical form of $A$.  (For example,
every closed term of type $\mathbb{N}$ reduces to a unique \emph{numeral} --- a term formed by applying $\mathrm{suc}$ some
finite number of times to 0.)
\end{itemize}

The \emph{univalence axiom} of Homotopy Type theory (HoTT) \todo{Citation} breaks the property of canonicity.  It postulates a
constant
\[ \isotoid : A \simeq B \rightarrow A = B \]
that is an inverse to the canonical function $A = B \rightarrow A \simeq B$.  When a computation reaches a point
where we eliminate a path (proof of equality) formed by $\isotoid$, it gets 'stuck'.

As possible solutions to this problem, we may try to do with a weaker property than canonicity, such as \emph{propositional canonicity}.
We may attempt to prove that every closed term of type $\mathbb{N}$ is \emph{propositionally} equal to a numeral.  (This is known as
\emph{Voevodsky's Conecture} \todo{Cite}.)  Or we may attempt to change the definition of equality to make $\isotoid$ definable (\cite{Polonsky14a}), or
shift to an entirely different type theory such as Cubical Type Theory \todo{Cite}.

We could also try a more conservative approach, and simply attempt to find a reduction relation for a type theory involving $\isotoid$ that satisfies
all three of the properties above.  There seems to be no reason \emph{a priori} to believe this is not possible, but it is difficult to do because
the full Homotopy Type Theory is a complex and interdependent system.  We can tackle the problem by adding univalence to a much simpler system, finding
a well-behaved reduction relation, then doing the same for more and more complex systems, gradually approaching the full strength of HoTT.

In this paper, we present a system we call $\lambda o e$, or predicative higher-order propositional logic.  It is a type theory with two universes: the universe $\Omega$
of \emph{propositions}, and the universe $U$ of \emph{types}.  The propositions are closed under $\sup$ (implication) and include $\bot$ (falsehood), and an equality proposition $M =_A N$ for
any type $A : U$ and terms $M : A$ and $N : A$.  The types include $\Omega$ itself and are closed under $\rightarrow$ (non-dependent function type).

There are two canonical forms for proofs of $M =_A N$.  For any term $M : A$, we have $\reff{M} : M =_A M$.  We also add univalence for this system, in this form:
if $\delta : \phi \sup \psi$ and $\epsilon : \psi \sup \phi$, then $\univ{\phi}{\psi}{\delta}{\epsilon} : \phi =_\Omega \psi$.  We present a reduction relation for this system, and prove it satisfies confluence, strong normalization and canonicity. \todo{Cross-reference lemma numbers.}  The reduction relation does not necessarily satisfy confluence on raw terms, but it does satisfy local confluence.  Hence, as
every typed term is strongly normalizing, we know by Newman's Lemma that the reduction is confluent on the typed terms.

For the future, we wish to expand the system with universal quantification, and expand it to a 2-dimensional system (with equations between proofs).

\todo{Elimination of the false proposition?}

\section{Predicative Higher-Order Propositional Logic}

We call the following type theory $\lambda o$, or \emph{predicative higher-order propositional logic}.  Its
syntax is given by the grammar:

\[
\begin{array}{lrcl}
\text{Type} & A & ::= & \Omega \mid A \rightarrow A \\
\text{Term} & M, \phi & ::= & x \mid \bot \mid \phi \sup \phi \mid \lambda x:A.M \mid MM \\
\text{Proof} & \delta & ::= & p \mid \lambda x:\phi.\delta \mid \delta \delta
\end{array}
\]
where $p$ is a \emph{proof variable} and $x$ is a \emph{term variable}.
Its rules of deduction are given in Figure \ref{fig:lambdao}

\begin{figure}
\[ \infer{\langle \rangle \vald}{} \qquad
\infer{\Gamma, x : A \vald}{\Gamma \vald} \qquad 
\infer{\Gamma, p : \phi \vald}{\Gamma \vdash \phi : \Omega} \]

\[ \infer[(x : A \in \Gamma)]{\Gamma \vdash x : A}{\Gamma \vald} \qquad
\infer[(p : \phi \in \Gamma)]{\Gamma \vdash p : \phi}{\Gamma \vald} \]

\[ \infer{\Gamma \vdash \bot : \Omega}{\Gamma \vald} \qquad
\infer{\Gamma \vdash \phi \rightarrow \psi : \Omega}{\Gamma \vdash \phi : \Omega \quad \Gamma \vdash \psi : \Omega} \]

\[ \infer{\Gamma \vdash M N : B} {\Gamma \vdash M : A \rightarrow B \quad \Gamma \vdash N : A} \qquad
\infer{\Gamma \vdash \delta \epsilon : \psi} {\Gamma \vdash \delta : \phi \rightarrow \psi \quad \Gamma \vdash \epsilon : \phi} \]

\[ \infer{\Gamma \vdash \lambda x:A.M : A \rightarrow B}{\Gamma, x : A \vdash M : B} \qquad
\infer{\Gamma \vdash \lambda p : \phi . \delta : \phi \rightarrow \psi}{\Gamma, p : \phi \vdash \delta : \psi} \]

\[ \infer[(\phi \simeq \phi)]{\Gamma \vdash \delta : \psi}{\Gamma \vdash \delta : \phi \quad \Gamma \vdash \psi : \Omega} \]
\caption{Rules of Deduction of $\lambda o$}
\label{fig:lambdao}
\end{figure}

\subsection{Extensional Equality}

On top of this system, we add an extensional equality relation.  We extend the grammar with

\[
\begin{array}{lrcl}
\text{Path} & P & ::= & e \mid \reff{M} \mid P \supset P \mid \univ{\phi}{\phi}{\delta}{\delta} \mid \triplelambda e : x =_A x . P \mid P P\\
\text{Proof} & \delta & ::= & \cdots \mid P^+ \mid P^- \\
\text{Context} & \Gamma & ::= & \cdots \mid \Gamma, e : M =_A M \\
\text{Judgement} & \mathcal{J} & ::= & \cdots \mid \Gamma \vdash P : M =_A M
\end{array}
\]

Note that, in the path $\triplelambda e : x =_A y . P$, the term variables $x$ and $y$ and the proof variable $e$ are all bound within $P$.

We add the rules of deduction given in Figure \ref{fig:lambdaoe}.

\begin{figure}
\[ \infer{\Gamma, e : M =_A N \vald}{\Gamma \vdash M : A \quad \Gamma \vdash N : A}
\qquad
\infer[e : M =_A N \in \Gamma]{\Gamma \vdash e : M =_A N}{\Gamma \vald} \]

\[ \infer{\Gamma \vdash \reff{M} : M =_A M}{\Gamma \vdash M : A}
\qquad
\infer{\Gamma \vdash P \rightarrow Q : \phi \rightarrow \psi =_\Omega \phi' \rightarrow \psi'}{\Gamma \vdash P : \phi =_\Omega \phi' \quad \Gamma \vdash Q : \psi =_\Omega \psi'} \]

\[ \infer{\Gamma \vdash \univ{\phi}{\psi}{\delta}{\epsilon} : \phi =_\Omega \psi}{\Gamma \vdash \delta : \phi \rightarrow \psi \quad \Gamma \vdash \epsilon : \psi \rightarrow \phi} 
\qquad
\infer{\Gamma \vdash P^+ : \phi \rightarrow \psi}{\Gamma \vdash P : \phi =_\Omega \psi}
\qquad
\infer{\Gamma \vdash P^- : \psi \rightarrow \phi}{\Gamma \vdash P : \psi =_\Omega \psi} \]

\[ \infer{\Gamma \vdash \triplelambda e : x =_A y . P : M =_{A \rightarrow B} N}{\Gamma, x : A, y : A, e : x =_A y \vdash M x =_B N y} \]

\[ \infer{\Gamma \vdash PQ : MN =_B M' N'}{\Gamma \vdash P : M =_{A \rightarrow B} M' \quad \Gamma \vdash Q : N =_A N'} \]

\[ \infer[(M \simeq_\beta M', N \simeq_\beta N')]{\Gamma \vdash P : M' =_A N'}{\Gamma \vdash P : M =_A N \quad \Gamma \vdash M' : A \quad \Gamma \vdash N' : A} \]
\caption{Rules of Deduction of $\lambda oe$}
\label{fig:lambdaoe}
\end{figure}

\mode<all>{\input{PHOPL/Rules.lagda}}

\subsection{The Reduction Relation}

\mode<all>{\input{PHOPL/Red.lagda}}

\subsection{Strong Normalization Proof}

\mode<all>{\input{PHOPL/Computable.lagda}}
\mode<all>{\input{PHOPL/MainProp1.lagda}}
\mode<all>{\input{PHOPL/MainProp.lagda}}

\section{$\lambda o i$}

\begin{frame}
\frametitle{Include equations in $\Omega$}

\begin{itemize}
\item
We can include the equations $M =_A N$ in our logic.
\onslide<2->{
\item
Now we can form (and prove) $sym_{MN} : M =_A N \supset N =_A M$ and $trans_{MNP} : M =_A N \supset N =_A P \supset M =_A P$ (by recursion on $A$).}
\end{itemize}

\[ \infer{\Gamma \vdash M =_A N : \Omega}{\Gamma \vdash M : A \quad \Gamma \vdash N : A} \]
\only<2->{\[ \infer{\Gamma \vdash \delta =^*_A \epsilon : (M =_A N) =_\Omega (M' =_A N')}
{\Gamma \vdash \delta : M =_A M' \quad \Gamma \vdash \epsilon : N =_A N'} \]}

\pause

New computation rules include:

\[ (\triplelambda^{F,G} e:x =_A y . \delta) =^* \reff{H} \]
\[ \rhd \mathsf{univ}_{F = H,G = H}(\lambda p. \triplelambda e:x=_Ay. (Gx =_{sym\ \delta} F y =_{p \reff{y}} H y), \]
\[ \lambda p. \triplelambda e:x=_A y. (F x =_{\delta} G y =_{p \reff{y}}) \]
\end{frame}

\section{Conclusion}

\begin{frame}
\frametitle{Conclusion}
\begin{itemize}[<+->]
\item
We have shown two systems that each have all these properties:
\begin{itemize}
\item
Univalence
\item
Strong Normalization
\item
Confluence of typed terms
\item
Canonicity
\end{itemize}
\item
So it is possible!
\item
The simplicity is due to the separation between terms and proofs.
\item
For the future: extract a normalizer.  Universal quantification.
\item
Follow the progress here: \url{www.github.com/radams78/Univalence}
\end{itemize}
\end{frame}

\todos

\begin{frame}
\frametitle{Bibliography}
\bibliography{type}
\end{frame}

\appendix

\section{About the Formalization}

\begin{frame}
\frametitle{About the Formalization}
This work is being formalized in Agda (work in progress).
\pause

It will involve several systems and reduction relations.

I want to prove only once:
\pause
\begin{itemize}[<+->]
\item
$M[x:=N][y:=P] \equiv M[y:=P[x:=N]][x:=N]$
\item
If $M \twoheadrightarrow N$ then $M[x:=P] \twoheadrightarrow N[x:=P]$
\item
If $M[x:=P]$ is SN then $M$ is SN.
\item
Etc.
\end{itemize}
\pause
The formalization includes a general notion of `grammar' and `reduction relation'.  (To do: general notion of derivation rules.)
\end{frame}

\input{Prelims.lagda}
\mode<all>{\input{Grammar/Taxonomy.lagda}}
\mode<all>{\input{Grammar/Base.lagda}}

We define the operations of replacement and substitution on
expressions.  

\input{Grammar/Substitution/PreOpFamily.lagda}
\input{Grammar/Substitution/OpFamily.lagda}

The details are given in Appendix \ref{appendix:repsub}.

\input{Grammar/Context.lagda}
\input{Reduction/Base.lagda}
\input{Reduction/SN.lagda}
%\input{PL/Grammar.lagda}
%\input{PL/Rules.lagda}
%\input{PL/Computable.lagda}

\section{Replacement and Substitution}
\label{appendix:repsub}

\input{Grammar/OpFamily/PreOpFamily.lagda}
\input{Grammar/OpFamily/Lifting.lagda}
\input{Grammar/OpFamily/LiftFamily.lagda}
\input{Grammar/OpFamily/Composition.lagda}
\input{Grammar/OpFamily/OpFamily.lagda}
\input{Grammar/Replacement.lagda}
\input{Grammar/Substitution/Lifting.lagda}
\input{Grammar/Substitution/RepSub.lagda}
\input{Grammar/Substitution/LiftFamily.lagda}
\input{Grammar/Substitution/Botsub.lagda}

\end{document}
